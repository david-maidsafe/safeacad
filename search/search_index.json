{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SAFE Fleming Bible This is a document that allows anyone in marketing to speak intelligently about Fleming, what it is and what it delivers at a technical level. This will be an iterative document, where we will add and amend as we learn and understand more about the Network. To ensure this is kept up-to-date, a version control log has been added so we can track on changes. Contents Glossary Sharding / Disjoint Sections Authorities Groups Sections Message Relay Secure Message Relay Chain PARSEC Node Ageing Version Log Version # Who Summary of changes Date v2 Ceilidh Changes based on TL feedback PARSEC added 15/04/2019 - TBC","title":"SAFE Fleming Bible"},{"location":"#safe-fleming-bible","text":"This is a document that allows anyone in marketing to speak intelligently about Fleming, what it is and what it delivers at a technical level. This will be an iterative document, where we will add and amend as we learn and understand more about the Network. To ensure this is kept up-to-date, a version control log has been added so we can track on changes.","title":"SAFE Fleming Bible"},{"location":"#contents","text":"Glossary Sharding / Disjoint Sections Authorities Groups Sections Message Relay Secure Message Relay Chain PARSEC Node Ageing","title":"Contents"},{"location":"#version-log","text":"Version # Who Summary of changes Date v2 Ceilidh Changes based on TL feedback PARSEC added 15/04/2019 - TBC","title":"Version Log"},{"location":"01_glossary/","text":"Glossary A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z A ABFT Asynchronous Byzantine Fault Tolerance Accumulating Node The node that collates the message and signatures before sending when the sending authority is multiple Accumulation at Source When proofs are accumulated at the source of a message rather than the destination Ack Acknowledgement, confirmation that a message has been received successfully Appendable data Ability to append information to an existing piece of data, you cannot change what already exists. Authority A label that is applied to any message that determines its ultimate destination Autonomous The ability for the network to manage data without human intervention B Bootstrapping A process to join the network. Anything that joins the network has to go through the Bootstrapping process Buffer Nodes additional to the minimum group size that are required before a split can occur to reduce merges. C Chain Links that couple together identifiers (descriptors) Client Individual computers CRUST C ommunications in Rust : It\u2019s a generic networking library that essentially connects two nodes/peers/computers directly without an intermediate server D Disjoint Section A group of Vaults defined by their XOR address prefix G Gossip Event A Gossip Event is any piece of information that is sent across the Network using the Gossip protocol. Group 8 Nodes with a close XOR address H Hop Hop is when you have to travel through neighbouring Sections in the network to reach your destination. I Invariant A set of rules which enable the Network to maintain a stable state Immutable data A data type that cannot be changed, and whose location is determined by the hash of the data itself. M Merge Merges happen when there are too few nodes (below minimum group size) in a Section so the nodes \u2018merge\u2019 with another Section. You can only merge with a sibling. Message in this context it\u2019s any network operation (gossiping messages, relay messages, new node joining, consensus) N Neighbour relations to sections determined by the Network Invariant . Neighbours are those sections which prefix differ by one bit, i.e the neighbour of \u201801\u2019 is \u201811\u2019 and \u201800\u2019, \u201810\u2019 is not a neighbour as you have to change both the \u20180\u2019 and the \u20181\u2019 (bits). Network Event Nodes attempt to communicate \u2018truths\u2019 to each other on the network Node individual device on the network Node age an autonomous and decentralised node reputation system that ranks nodes based on their age. P PARSEC Protocol for Asynchronous, Reliable, Secure and Efficient Consensus an algorithm that orders section votes. Prefix first numbers (bits) at the beginning of the XOR address Proxy Acts as an intermediary between the client and the network / single authority Q Quorum quorum is the minimum number needed to cast a vote before an action can take place R Resource proof CPU, reliability bandwidth, features a new node needs to prove on a continuous basis S Secure Message Relay a way of validating the senders of messages (not the messages) across Disjoint Sections of the Network. Section is a subset of all the addresses on the network. Section info an object that has info on the section including prefix, version, members - public identity (public key and encryption key), previous hash, hash Sharding The process by which sections change size, the location of responsibility and often their Neighbours due to splits and merges. Sibling are a special case of neighbours, siblings prefixes differ by only 1 bit at the very last bit. In the example above 01 would be the sibling to 00. Siblings are of particular importance in the case of mergers Split split occurs in a section when the section gets too big and unbalanced. Swarm the process by which one node in a Section shares a received message with every other node in that Section V Vault Vector list Version the members of a section at a given point in time. X XOR Every node or piece of data in the Network has a XOR address, which is a 256-bit long identifier","title":"Glossary"},{"location":"01_glossary/#glossary","text":"A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z","title":"Glossary"},{"location":"01_glossary/#a","text":"","title":"A"},{"location":"01_glossary/#abft","text":"Asynchronous Byzantine Fault Tolerance","title":"ABFT"},{"location":"01_glossary/#accumulating-node","text":"The node that collates the message and signatures before sending when the sending authority is multiple","title":"Accumulating Node"},{"location":"01_glossary/#accumulation-at-source","text":"When proofs are accumulated at the source of a message rather than the destination","title":"Accumulation at Source"},{"location":"01_glossary/#ack","text":"Acknowledgement, confirmation that a message has been received successfully","title":"Ack"},{"location":"01_glossary/#appendable-data","text":"Ability to append information to an existing piece of data, you cannot change what already exists.","title":"Appendable data"},{"location":"01_glossary/#authority","text":"A label that is applied to any message that determines its ultimate destination","title":"Authority"},{"location":"01_glossary/#autonomous","text":"The ability for the network to manage data without human intervention","title":"Autonomous"},{"location":"01_glossary/#b","text":"","title":"B"},{"location":"01_glossary/#bootstrapping","text":"A process to join the network. Anything that joins the network has to go through the Bootstrapping process","title":"Bootstrapping"},{"location":"01_glossary/#buffer","text":"Nodes additional to the minimum group size that are required before a split can occur to reduce merges.","title":"Buffer"},{"location":"01_glossary/#c","text":"","title":"C"},{"location":"01_glossary/#chain","text":"Links that couple together identifiers (descriptors)","title":"Chain"},{"location":"01_glossary/#client","text":"Individual computers","title":"Client"},{"location":"01_glossary/#crust","text":"C ommunications in Rust : It\u2019s a generic networking library that essentially connects two nodes/peers/computers directly without an intermediate server","title":"CRUST"},{"location":"01_glossary/#d","text":"","title":"D"},{"location":"01_glossary/#disjoint-section","text":"A group of Vaults defined by their XOR address prefix","title":"Disjoint Section"},{"location":"01_glossary/#g","text":"","title":"G"},{"location":"01_glossary/#gossip-event","text":"A Gossip Event is any piece of information that is sent across the Network using the Gossip protocol.","title":"Gossip Event"},{"location":"01_glossary/#group","text":"8 Nodes with a close XOR address","title":"Group"},{"location":"01_glossary/#h","text":"","title":"H"},{"location":"01_glossary/#hop","text":"Hop is when you have to travel through neighbouring Sections in the network to reach your destination.","title":"Hop"},{"location":"01_glossary/#i","text":"","title":"I"},{"location":"01_glossary/#invariant","text":"A set of rules which enable the Network to maintain a stable state","title":"Invariant"},{"location":"01_glossary/#immutable-data","text":"A data type that cannot be changed, and whose location is determined by the hash of the data itself.","title":"Immutable data"},{"location":"01_glossary/#m","text":"","title":"M"},{"location":"01_glossary/#merge","text":"Merges happen when there are too few nodes (below minimum group size) in a Section so the nodes \u2018merge\u2019 with another Section. You can only merge with a sibling.","title":"Merge"},{"location":"01_glossary/#message","text":"in this context it\u2019s any network operation (gossiping messages, relay messages, new node joining, consensus)","title":"Message"},{"location":"01_glossary/#n","text":"","title":"N"},{"location":"01_glossary/#neighbour","text":"relations to sections determined by the Network Invariant . Neighbours are those sections which prefix differ by one bit, i.e the neighbour of \u201801\u2019 is \u201811\u2019 and \u201800\u2019, \u201810\u2019 is not a neighbour as you have to change both the \u20180\u2019 and the \u20181\u2019 (bits).","title":"Neighbour"},{"location":"01_glossary/#network-event","text":"Nodes attempt to communicate \u2018truths\u2019 to each other on the network","title":"Network Event"},{"location":"01_glossary/#node","text":"individual device on the network","title":"Node"},{"location":"01_glossary/#node-age","text":"an autonomous and decentralised node reputation system that ranks nodes based on their age.","title":"Node age"},{"location":"01_glossary/#p","text":"","title":"P"},{"location":"01_glossary/#parsec","text":"Protocol for Asynchronous, Reliable, Secure and Efficient Consensus an algorithm that orders section votes.","title":"PARSEC"},{"location":"01_glossary/#prefix","text":"first numbers (bits) at the beginning of the XOR address","title":"Prefix"},{"location":"01_glossary/#proxy","text":"Acts as an intermediary between the client and the network / single authority","title":"Proxy"},{"location":"01_glossary/#q","text":"","title":"Q"},{"location":"01_glossary/#quorum","text":"quorum is the minimum number needed to cast a vote before an action can take place","title":"Quorum"},{"location":"01_glossary/#r","text":"","title":"R"},{"location":"01_glossary/#resource-proof","text":"CPU, reliability bandwidth, features a new node needs to prove on a continuous basis","title":"Resource proof"},{"location":"01_glossary/#s","text":"","title":"S"},{"location":"01_glossary/#secure-message-relay","text":"a way of validating the senders of messages (not the messages) across Disjoint Sections of the Network.","title":"Secure Message Relay"},{"location":"01_glossary/#section","text":"is a subset of all the addresses on the network.","title":"Section"},{"location":"01_glossary/#section-info","text":"an object that has info on the section including prefix, version, members - public identity (public key and encryption key), previous hash, hash","title":"Section info"},{"location":"01_glossary/#sharding","text":"The process by which sections change size, the location of responsibility and often their Neighbours due to splits and merges.","title":"Sharding"},{"location":"01_glossary/#sibling","text":"are a special case of neighbours, siblings prefixes differ by only 1 bit at the very last bit. In the example above 01 would be the sibling to 00. Siblings are of particular importance in the case of mergers","title":"Sibling"},{"location":"01_glossary/#split","text":"split occurs in a section when the section gets too big and unbalanced.","title":"Split"},{"location":"01_glossary/#swarm","text":"the process by which one node in a Section shares a received message with every other node in that Section","title":"Swarm"},{"location":"01_glossary/#v","text":"","title":"V"},{"location":"01_glossary/#vault","text":"","title":"Vault"},{"location":"01_glossary/#vector","text":"list","title":"Vector"},{"location":"01_glossary/#version","text":"the members of a section at a given point in time.","title":"Version"},{"location":"01_glossary/#x","text":"","title":"X"},{"location":"01_glossary/#xor","text":"Every node or piece of data in the Network has a XOR address, which is a 256-bit long identifier","title":"XOR"},{"location":"02_sharding/","text":"Sharding / Disjoint Sections Summary Strategy used to scale a Network by distributing the load between \"shards\" where each \"shard\" is only responsible for part of the Network's functioning. In the SAFE Network, Disjoint Sections act as shards which is process by which sections change size, the location of responsibility and often their Neighbours due to splits and merges. Splits Triggered by a new node joining Split is the process by which a section makes a binary split into two smaller sections. Splits only occur once certain factors have been met: There must be a minimum group size for each child Plus a buffer Splits are a valid loss of information, neighbours and responsibility for a node Merges If the nodes in a Section fall below the \u2018MinimumGroupSize\u2019, the nodes of one Section will merge with their sibling. Merges lead to an increase in area of responsibility. Status Present in Alpha 2 / unique to Safe How it works Before we get into Sections, we\u2019ll just briefly touch upon bootstrapping When a node first joins, it contacts a proxy That proxy sends the node to a Section which asks the newcomer to generate a new public/private keypair within a specified range that is covered by that Section. This is different to Bitcoin for SAFE, the ID generation is random, but still defined to a given range. BTC generated at random not within range. The new node now has a Public Signing Key which doubles as its XOR address on the Network Sections A subset of all the addresses on the Network. The Network is a 32 byte or 256 bit range of addresses. 256 bit = 2 to the power of 256 possible combinations (78 digits) The Network Invariant specified for Disjoint sections: - Each prefix is responsible for part of the network, a node cannot be in more than 1 Section (unlike a Group) - No overlap because the Section is defined by the node\u2019s prefix - So a node that has a prefix 11001\u2026 will be in that Section - it cannot be in e.g. Section 10101 Neighbours: Are Sections that have a prefix which differs from their own prefix by one single bit. In the example of: 00, 01, 10, 11 (which covers the whole network space) 00\u2019s neighbours are 01 and 10 only. 11 does not count as a Neighbour (as the prefix differs by 2 bits). Once you identify a Section as your neighbour, they also identify you as their Neighbour. Siblings: Are a special subset of Neighbours. Siblings have prefixes that differ by only 1 bit at the very last bit. In the example above, 01 would be the sibling to 00. Siblings are crucial for merges. If no Sibling exists when a merge is required, the Sections would have to collapse/merge until a Sibling is created (i.e. the tree collapses upwards until it ends up with a Section whose prefix differs by only the last bit). Splitting: Splits involve a binary split of one disjoint section into two sibling disjoint sections. Involves a valid loss of information from a node as it becomes part of a different section which are responsible for a smaller XOR space Don't require an external source of trust as they got enough information from the section they used to be a member of. (As opposed to merges where you need to gain info from your sibling and establish trust in the process) Removing a node will never trigger a disjoint section to split Split mechanism: A split may occur when a node joins the section. In order for a split to occur there must be a minimum number (8 - current group size) of peers and a buffer for each child. The buffer is required to reduce the likelihood of a re-merge as these are expensive/resource intensive network activities. As there is continual node loss and churn. The buffer is required to minimise merge events being triggered as a result of a node or two disconnecting. We do not want too many merges as they are resource heavy. All prefix changes are Network expensive. Splits do not need to happen immediately as unlike mergers there is no risk of data loss, so these can be a key area for Network throttle. An unbalanced section can split into more than one child on one side. This is known as a multi-split. I.e. 01 would split into 010 and 111. This would occur if there was a very large number of nodes with the prefix 11 and as soon as the split into 10 and 11 occurs there is already enough to split into 110 and 111. A split represents a valid loss of information. Nodes from a splitting section will be responsible for less information following a split, as they are now responsible for a smaller section of the Network. This will not be not in Fleming but will be included in Maxwell as there is no data in Fleming This has benefits to scalability and performance, as the Network grows sections are responsible for less rather than other models in which the greater the information the slower Splits lead to the loss of neighbours Merging: Are far more complicated than splits as sections gain information. The merging sections must be able to trust the previously responsible section for all the information. Two disjoint sections are merged when one of the siblings membership falls below the minimum group size. A Merge will result in a gain of information Removing a node may trigger the merge of two disjoint sections Merges are computationally expensive for the Network - as they require nodes to gain new information (which they need to validate in order to trust it) and responsibilities. It also means that the Nodes\u2019 prefix will change when they form a new Section Note: post-Fleming, when we have data, the load on the Network will increase, which can impact performance A merge must happen immediately to ensure that data is not inaccessible Features Bootstrapping When a new node joins the Network, it will contact a proxy node. That proxy directs the node to a Section. That Section will then require the new node to generate a Public Signing Key(pair) that is within a specified range (i.e. the range that Section covers). Once it has done this, its functionality will then be tested (via Resource Proof - i.e. does it have the necessary bandwidth etc). Balanced Relocation When a new node requests to join a section, the section will look at the identities of the existing members and in order to ensure balance in the event of a split. Splits A split occurs in a section when the section gets too big and unbalanced. Merge Merges happen when there are too few nodes (below minimum group size) in a Section so the nodes \u2018merge\u2019 with another Section. You can only merge with a sibling. Benefits Scalability","title":"Sharding / Disjoint Sections"},{"location":"02_sharding/#sharding-disjoint-sections","text":"","title":"Sharding / Disjoint Sections"},{"location":"02_sharding/#summary","text":"Strategy used to scale a Network by distributing the load between \"shards\" where each \"shard\" is only responsible for part of the Network's functioning. In the SAFE Network, Disjoint Sections act as shards which is process by which sections change size, the location of responsibility and often their Neighbours due to splits and merges.","title":"Summary"},{"location":"02_sharding/#splits","text":"Triggered by a new node joining Split is the process by which a section makes a binary split into two smaller sections. Splits only occur once certain factors have been met: There must be a minimum group size for each child Plus a buffer Splits are a valid loss of information, neighbours and responsibility for a node","title":"Splits"},{"location":"02_sharding/#merges","text":"If the nodes in a Section fall below the \u2018MinimumGroupSize\u2019, the nodes of one Section will merge with their sibling. Merges lead to an increase in area of responsibility.","title":"Merges"},{"location":"02_sharding/#status","text":"Present in Alpha 2 / unique to Safe","title":"Status"},{"location":"02_sharding/#how-it-works","text":"Before we get into Sections, we\u2019ll just briefly touch upon bootstrapping When a node first joins, it contacts a proxy That proxy sends the node to a Section which asks the newcomer to generate a new public/private keypair within a specified range that is covered by that Section. This is different to Bitcoin for SAFE, the ID generation is random, but still defined to a given range. BTC generated at random not within range. The new node now has a Public Signing Key which doubles as its XOR address on the Network","title":"How it works"},{"location":"02_sharding/#sections","text":"A subset of all the addresses on the Network. The Network is a 32 byte or 256 bit range of addresses. 256 bit = 2 to the power of 256 possible combinations (78 digits) The Network Invariant specified for Disjoint sections: - Each prefix is responsible for part of the network, a node cannot be in more than 1 Section (unlike a Group) - No overlap because the Section is defined by the node\u2019s prefix - So a node that has a prefix 11001\u2026 will be in that Section - it cannot be in e.g. Section 10101","title":"Sections"},{"location":"02_sharding/#neighbours","text":"Are Sections that have a prefix which differs from their own prefix by one single bit. In the example of: 00, 01, 10, 11 (which covers the whole network space) 00\u2019s neighbours are 01 and 10 only. 11 does not count as a Neighbour (as the prefix differs by 2 bits). Once you identify a Section as your neighbour, they also identify you as their Neighbour.","title":"Neighbours:"},{"location":"02_sharding/#siblings","text":"Are a special subset of Neighbours. Siblings have prefixes that differ by only 1 bit at the very last bit. In the example above, 01 would be the sibling to 00. Siblings are crucial for merges. If no Sibling exists when a merge is required, the Sections would have to collapse/merge until a Sibling is created (i.e. the tree collapses upwards until it ends up with a Section whose prefix differs by only the last bit).","title":"Siblings:"},{"location":"02_sharding/#splitting","text":"Splits involve a binary split of one disjoint section into two sibling disjoint sections. Involves a valid loss of information from a node as it becomes part of a different section which are responsible for a smaller XOR space Don't require an external source of trust as they got enough information from the section they used to be a member of. (As opposed to merges where you need to gain info from your sibling and establish trust in the process) Removing a node will never trigger a disjoint section to split","title":"Splitting:"},{"location":"02_sharding/#split-mechanism","text":"A split may occur when a node joins the section. In order for a split to occur there must be a minimum number (8 - current group size) of peers and a buffer for each child. The buffer is required to reduce the likelihood of a re-merge as these are expensive/resource intensive network activities. As there is continual node loss and churn. The buffer is required to minimise merge events being triggered as a result of a node or two disconnecting. We do not want too many merges as they are resource heavy. All prefix changes are Network expensive. Splits do not need to happen immediately as unlike mergers there is no risk of data loss, so these can be a key area for Network throttle. An unbalanced section can split into more than one child on one side. This is known as a multi-split. I.e. 01 would split into 010 and 111. This would occur if there was a very large number of nodes with the prefix 11 and as soon as the split into 10 and 11 occurs there is already enough to split into 110 and 111. A split represents a valid loss of information. Nodes from a splitting section will be responsible for less information following a split, as they are now responsible for a smaller section of the Network. This will not be not in Fleming but will be included in Maxwell as there is no data in Fleming This has benefits to scalability and performance, as the Network grows sections are responsible for less rather than other models in which the greater the information the slower Splits lead to the loss of neighbours","title":"Split mechanism:"},{"location":"02_sharding/#merging","text":"Are far more complicated than splits as sections gain information. The merging sections must be able to trust the previously responsible section for all the information. Two disjoint sections are merged when one of the siblings membership falls below the minimum group size. A Merge will result in a gain of information Removing a node may trigger the merge of two disjoint sections Merges are computationally expensive for the Network - as they require nodes to gain new information (which they need to validate in order to trust it) and responsibilities. It also means that the Nodes\u2019 prefix will change when they form a new Section Note: post-Fleming, when we have data, the load on the Network will increase, which can impact performance A merge must happen immediately to ensure that data is not inaccessible","title":"Merging:"},{"location":"02_sharding/#features","text":"","title":"Features"},{"location":"02_sharding/#bootstrapping","text":"When a new node joins the Network, it will contact a proxy node. That proxy directs the node to a Section. That Section will then require the new node to generate a Public Signing Key(pair) that is within a specified range (i.e. the range that Section covers). Once it has done this, its functionality will then be tested (via Resource Proof - i.e. does it have the necessary bandwidth etc).","title":"Bootstrapping"},{"location":"02_sharding/#balanced-relocation","text":"When a new node requests to join a section, the section will look at the identities of the existing members and in order to ensure balance in the event of a split.","title":"Balanced Relocation"},{"location":"02_sharding/#splits_1","text":"A split occurs in a section when the section gets too big and unbalanced.","title":"Splits"},{"location":"02_sharding/#merge","text":"Merges happen when there are too few nodes (below minimum group size) in a Section so the nodes \u2018merge\u2019 with another Section. You can only merge with a sibling.","title":"Merge"},{"location":"02_sharding/#benefits","text":"Scalability","title":"Benefits"},{"location":"03_authorities/","text":"Authorities Summary The relaying of messages across the network is determined by authorities. Messages can be sent from, or to, a single node or a collection of nodes. Each message must have sender destination details. For all authorities other than PrefixSection this is a full XOR address (and Client Public ID for Client authority), for PrefixSection it is a prefix . Authorities can be thought of as address labels on an envelope which detail the destination and sender address. Status Existing feature of the SAFE Network Types of authorities Authorities can be either singular authorities (single) or group authorities (multiple nodes). This means that the message is either verified by a single node or a group of nodes. Singular authorities No verification is required from other sources in order to relay the message. - #### ManagedNode Can be the source or final destination of the message and it\u2019s address is the given node address. - #### Client Can be the source or final destination of the message. A client authority is a client connecting to the network via a proxy node. The message must specify the proxy node address and the public ID of the client. Multiple (Group) authorities: In order to relay the message it must be verified by a quorum of nodes in either the section or group. Section: Section : If the destination authority is Section then all nodes within the section receive the message. If the source is Section then a quorum from the section nodes must verify the message in order to relay it. PrefixSection : If the address is defined as a prefix (rather than an XOR location), the message is received by all sections (and thus nodes) within that prefix range (the \u2018root\u2019 level prefix and all child sections of that prefix). Group: ClientManager, NodeManager, NaeManager Require quorum agreement from the group of nodes closest to the source. Examples The following are some examples of message relay from and to different authorities. Section Authority (SA) to a Managed Node (MN) The node within the section address closest to the hash of the destination, acts as the accumulation node (indicated in orange below) and, if it gets verification from a quorum of the section nodes, sends the message to the destination (indicated in red below) via section relay\u2026 ManagedNode to PrefixSection A single ManagedNode (MN) sends a message to a PrefixSection (PSA). The ManagedNode (indicated in orange below) sends the message to the destination prefix (as a Single Authority it does not require quorum agreement prior to sending). Once the prefix section receives the message it delivers the message to all nodes within the prefix. Features Group authorities Singular authorities Benefits Range of authorities enable the Network to transport communication effectively and honestly The categorisation of single versus group nodes and this determines how the message is relayed","title":"Authorities"},{"location":"03_authorities/#authorities","text":"","title":"Authorities"},{"location":"03_authorities/#summary","text":"The relaying of messages across the network is determined by authorities. Messages can be sent from, or to, a single node or a collection of nodes. Each message must have sender destination details. For all authorities other than PrefixSection this is a full XOR address (and Client Public ID for Client authority), for PrefixSection it is a prefix . Authorities can be thought of as address labels on an envelope which detail the destination and sender address.","title":"Summary"},{"location":"03_authorities/#status","text":"Existing feature of the SAFE Network","title":"Status"},{"location":"03_authorities/#types-of-authorities","text":"Authorities can be either singular authorities (single) or group authorities (multiple nodes). This means that the message is either verified by a single node or a group of nodes.","title":"Types of authorities"},{"location":"03_authorities/#singular-authorities","text":"No verification is required from other sources in order to relay the message. - #### ManagedNode Can be the source or final destination of the message and it\u2019s address is the given node address. - #### Client Can be the source or final destination of the message. A client authority is a client connecting to the network via a proxy node. The message must specify the proxy node address and the public ID of the client.","title":"Singular authorities"},{"location":"03_authorities/#multiple-group-authorities","text":"In order to relay the message it must be verified by a quorum of nodes in either the section or group.","title":"Multiple (Group) authorities:"},{"location":"03_authorities/#section","text":"Section : If the destination authority is Section then all nodes within the section receive the message. If the source is Section then a quorum from the section nodes must verify the message in order to relay it. PrefixSection : If the address is defined as a prefix (rather than an XOR location), the message is received by all sections (and thus nodes) within that prefix range (the \u2018root\u2019 level prefix and all child sections of that prefix).","title":"Section:"},{"location":"03_authorities/#group-clientmanager-nodemanager-naemanager","text":"Require quorum agreement from the group of nodes closest to the source.","title":"Group: ClientManager, NodeManager, NaeManager"},{"location":"03_authorities/#examples","text":"The following are some examples of message relay from and to different authorities.","title":"Examples"},{"location":"03_authorities/#section-authority-sa-to-a-managed-node-mn","text":"The node within the section address closest to the hash of the destination, acts as the accumulation node (indicated in orange below) and, if it gets verification from a quorum of the section nodes, sends the message to the destination (indicated in red below) via section relay\u2026","title":"Section Authority (SA) to a Managed Node (MN)"},{"location":"03_authorities/#managednode-to-prefixsection","text":"A single ManagedNode (MN) sends a message to a PrefixSection (PSA). The ManagedNode (indicated in orange below) sends the message to the destination prefix (as a Single Authority it does not require quorum agreement prior to sending). Once the prefix section receives the message it delivers the message to all nodes within the prefix.","title":"ManagedNode to PrefixSection"},{"location":"03_authorities/#features","text":"Group authorities Singular authorities","title":"Features"},{"location":"03_authorities/#benefits","text":"Range of authorities enable the Network to transport communication effectively and honestly The categorisation of single versus group nodes and this determines how the message is relayed","title":"Benefits"},{"location":"04_sections/","text":"Groups Sections Summary Groups: Dictate which nodes control which data. Made up of 8 nodes based on closeness of XOR address and because of that can overlap. Sections: Govern how nodes send messages across the Network Made up of an undefined number of nodes and ordered on prefix addresses. Sections can merge and split to ensure efficient operation on the network. Status Existing feature of the Network What is a section? A section is a subset of all the addresses on the Network\u2019s 256 bit address space. Therefore a Section is responsible for a specific part of the Network as defined by an XOR location. Minimum nodes for a Section defined by \u2018MinimumSectionSize\u2019, currently this is likely to be 8 (5 sufficient for consensus and 3 for buffer) All nodes in a section will have the same prefix which also relates to the section of the network they are responsible for. Sections do not overlap and nodes can only be part of one section. This means each section is only aware of, and connected to, themselves and their neighbours. The Chain is a record of information, that can be utilised by anyone. The Chain is a single chronological list of actions that have occurred in each of the Sections. We can see our chain and parts of other (neighbours) sections chains. Neighbours to a section are determined by the network invariant. To be a Neighbour, it must have a prefix which differs by only a single bit from another node. What is a Group A Group is a group size number of nodes (8) and this is defined by their closeness to a XOR address. Unlike Sections, these can overlap and nodes can be members of a number of different Groups. The closer a node is to an address space, the more info it has about the address (similar to the knowledge of the [country, city, postcode, house address]) Security increases as Network grows and this is because each node becomes responsible for a tighter group of addresses. Sections Groups How it works A new node joins the Network (via Bootstrap process) Contacts a (dumb) proxy Proxy sends new node to a Section New node has to then generate keypair that falls within range of Section addresses So if sent to Section 11010\u2026, node\u2019s address must also start with 11010... Unlike Bitcoin where any random address is created The public signing key it has created now acts as that node\u2019s new location on the Network New Section now checks new node is suitable (Resource Proof)","title":"Groups & Sections"},{"location":"04_sections/#groups-sections","text":"","title":"Groups &amp; Sections"},{"location":"04_sections/#summary","text":"","title":"Summary"},{"location":"04_sections/#groups","text":"Dictate which nodes control which data. Made up of 8 nodes based on closeness of XOR address and because of that can overlap.","title":"Groups:"},{"location":"04_sections/#sections","text":"Govern how nodes send messages across the Network Made up of an undefined number of nodes and ordered on prefix addresses. Sections can merge and split to ensure efficient operation on the network.","title":"Sections:"},{"location":"04_sections/#status","text":"Existing feature of the Network","title":"Status"},{"location":"04_sections/#what-is-a-section","text":"A section is a subset of all the addresses on the Network\u2019s 256 bit address space. Therefore a Section is responsible for a specific part of the Network as defined by an XOR location. Minimum nodes for a Section defined by \u2018MinimumSectionSize\u2019, currently this is likely to be 8 (5 sufficient for consensus and 3 for buffer) All nodes in a section will have the same prefix which also relates to the section of the network they are responsible for. Sections do not overlap and nodes can only be part of one section. This means each section is only aware of, and connected to, themselves and their neighbours. The Chain is a record of information, that can be utilised by anyone. The Chain is a single chronological list of actions that have occurred in each of the Sections. We can see our chain and parts of other (neighbours) sections chains. Neighbours to a section are determined by the network invariant. To be a Neighbour, it must have a prefix which differs by only a single bit from another node.","title":"What is a section?"},{"location":"04_sections/#what-is-a-group","text":"A Group is a group size number of nodes (8) and this is defined by their closeness to a XOR address. Unlike Sections, these can overlap and nodes can be members of a number of different Groups. The closer a node is to an address space, the more info it has about the address (similar to the knowledge of the [country, city, postcode, house address]) Security increases as Network grows and this is because each node becomes responsible for a tighter group of addresses. Sections Groups","title":"What is a Group"},{"location":"04_sections/#how-it-works","text":"A new node joins the Network (via Bootstrap process) Contacts a (dumb) proxy Proxy sends new node to a Section New node has to then generate keypair that falls within range of Section addresses So if sent to Section 11010\u2026, node\u2019s address must also start with 11010... Unlike Bitcoin where any random address is created The public signing key it has created now acts as that node\u2019s new location on the Network New Section now checks new node is suitable (Resource Proof)","title":"How it works"},{"location":"05_messaging/","text":"Message Relay SMR Summary Sending and / or receiving a new message from a source to a destination Status Message relay - Alpha 2 / SMR - Fleming How it works Traversal Logic: While nodes only maintain an awareness of their neighbouring nodes, and connect when necessary, if a message needs to travel across the network out with its neighbouring nodes, how do messages reach their destination? The current mechanism is passing a message between two distant sections relies on a chain of relay nodes, one per section, across the network. All of the relaying nodes then pass the message to all of the relaying nodes in the next hop (jumping across sections) making it certain that the message will make it to the recipient, For a node to message another node, the source node needs to know the destination nodes address, which also indicates the prefix section it\u2019s in. If the source can\u2019t send directly to the destination, it identifies the closest prefix possible from it's knowledge of neighbouring sections. So in the first example below (the first box) the source node (MN) is in prefix 1111 and wants to send to the destination node in prefix 0000. Because it can\u2019t send it directly, source node identifies that it\u2019s neighbour (111) is the next closest to the destination. The message is sent from 1111 111 (first hop). Then the process starts again. Section 111, if can\u2019t send directly to the destination, it identifies the closest prefix possible from it's knowledge of neighbouring sections (it\u2019s neighbouring sections are 011, 101, 110). 111 therefore sends to 011 (second hop). The process repeats. Section 011 looks at its neighbours (001, 010, 111) and identifies 001 as the next closet (third hop). Finally 001 is able to send the message to 000 (final hop to destination) and on to the destination node itself. Using the same logic, you can see how a message is sent from a section to a section (2nd box) and also from a group to another group (3rd box). But why do we need messages to be sent to three different types of destinations? To expand, we\u2019ve listed out a few example scenarios for when a particular destination type is used: Send to a node - only concerns that node Send to a section - accepting a new node into the section Send to a group - storing a piece of data By using this logic, we can now understand message relay. Message Relay We\u2019ll run through an example to help us understand message relay. Here we are sending a node (A) in section 00 to a node (X) in section 11. When any node tries to send a message, it must first accumulate information that is required to send the message (hence it\u2019s called the Accumulating Node). In addition to the message, it also has to have a quorum of signatures from the other nodes in its Section to confirm that it is validly allowed to send a message. That quorum is defined as a simple majority of nodes in a Section (so in this example, there are 6 nodes. If B C signs it, it reaches quorum. By getting a Quorum of signatures, it proves that it is a trusted sender in the eyes of the Network. If the node did not have a quorum of signatures from its Section, it would simply be an untrusted message as you can\u2019t trust a single node (which could be malicious). A now has a quorum of its signatures. A being in Section 00 identifies its neighbour as 10. In that Section, node is passed the message to G as it's closest to the hash to the message. G now has it. This is classed as a \u2018hop\u2019. Once it is as G in Section 10, she now identifies her neighbour as 11 where is where the destination X lives. This is passed over and now with message relay is complete. As you see Section 01 is greyed out. This is because the message doesn't need to traverse to that section to get to its destination. Messages that traverse the Alpha 2 Network currently don\u2019t require a quorum of signatures. This means that any malicious node could generate fictitious keypair identities for nodes that it claims are valid nodes in Sections further back in the message chain - and the recipient would have no way of checking this. In the above example as 11 does not know 00 they are not aware of the member list of 00. Therefore, G could create false key pairs which look like nodes from section 00 (ie with the prefix 00). G could send a message to X claiming it was from A and X has no way to validate this. Secure message relay mitigates this as a quorum of 01 will have signed the member list of 00 and these signatures will be attached to the message. As X knows and trust the members of 01 their signatures on the membership of 00 provides validity to the message coming from a true A. We\u2019ll now go into this in more detail. Secure Message Relay (SMR) So Secure Message Relay in Fleming gives the SAFE Network a way of ensuring that any messages sent across isolated parts of the Network (via hops through Neighbours) can be verified as trustworthy - enabling the Network to scale infinitely without weakening the trust requirements. This is not a problem that any other project today has been able to solve (as far as we are aware). In simple terms: SMR simply a chain of trust / validating the senders (not the message) Before we go any further we\u2019ll discuss Accumulation and Routes briefly. Accumulation: Each message requires a quorum of signatures in order that it can be trusted by the recipient. There are two options here on quorum: Accumulating at source = collating at source Accumulating at destination = collating at destination In the Network we use the first option as it takes less messages and is more efficient. Here is an example: As you can see, the accumulation at source is a simpler route with less messages and is more efficient. The accumulation at destination, the network is firing messages through any means possible in hope one lands and is acknowledged by the destination node. Routes: How do the nodes know they have the correct message? Let\u2019s use another example. The message sender is Section 00 and A is the accumulating node. The next step is G which is determined by which node is closest (XOR) to the hash of the message. Closeness to a hash is used to balance load across the network. To avoid a single point of failure, the source will send a message to a destination and they will wait for an ACK. ACK (acknowledgement) is quorum at the destination that the message has got through. If the source does not receive an ACK within a given time frame, the source will keep trying until one is received. Routing of messages on SAFE is subject to time limits to ensure the Network is working as intended and to ensure that false messages are not transferred. You can't lie about receiving an ACK. If they don't get an ACK, the section will choose another node and different route. In the example below, the blue line represents the first route however no ACK was received. As the ranking is defined by XOR, the 2nd attempt on route 2 is then defined on the 2nd closest XOR in each section. This process continues until an ACK is received. Routes Convergence: This is when routes are happening in different hops. This example above is Section 00 sending a message to Section 11. A is the accumulating node and sending it through D. However, D in Section 01 is malicious and doesn't send the message to the given destination 11. However in a network of disjoint sections we have churn. So the nodes are not static in each section. So in the example below, Section 01 has receieved a new node X. The next Node, B, then tries to send the message again but as now X is first in the list so it hits D again. Secure Message Relay Each time a section performs churn they notify their neighbours of any updates to their section info. Once a neighbour has the new info each member performs validations on this change, passes it through PARSEC and signs the PARSEC event. Quorum needs to be reached, then these signed events are attached the neighbour info. When a single node is sending a messages this signed neighbour info is attached so the destination can validate the sender even though they are not neighbours. This info includes the signatures of known and trusted nodes as well as the key pairs of the sender (in this example) this means no node along the journey can falsify the message or its sender. Our info: what we know in our section Their Knowledge: what your neighbours know about you as far as we know Neighbour info: what we know about our neighbours Successors Successors are added to the meta-info, to show the sequence of section versions from the version indicated in TheirInfo and the current version. This is done in case the neighbours have a differing version of our section than the sending section believes This is best explained through an example, please see below: Network set up This is the given network set up. ``` Pfx-10 { /* Nodes: A(was added in A4) .. */ - Our-Infos: A1,A2,A3,A4,A5 - Their-Knowledge: 00-A2, 11-A4 - Neighbour-Infos: 11(B3)-A3, 10(C4)-A2 } Pfx-11 { /* Nodes: B(was added in B2) .. */ - Our-Infos: B1,B2,B3,B4 - Their-Knowledge: 10-B2, 01-B3 - Neighbour-Infos: 10(A5)-B3, 01(D4)-B3 } Pfx-00 { /* Nodes: C(was added in C3) .. */ \u0002wzxhzdk:0\u0003 |sds | This is the given network set up. Here we can see we have 4 Prf. Sections with nodes A, B, C & D. If we take PrfSec 10, we see the nodes is A and was added when they were at version A4. In our section 10, we know that we\u2019re on A5. Our neighbours 00 know we\u2019re on A2 & 11 A4. You can see they don't have the most up to date information and this is due to churn. We know we signed B3 in Section 11 and C4 in 10. Q: Quorum PS: ProvingSections M: Message M { src: MN(A) dst: PfxSec(01) content: \u201cBye\u201d } meta-info { src_section: None sigs_of_msg: None PS: Empty } Here is the message. So the src (source) is a MN (managednode) A. We know A is in PfxSec 10. Dst (destination) is were the node is going. In this instance it's going to PrxSec 01. This example means we\u2019re going from a ManagedNode to a section. The meta info is empty at the moment. Start at A (prf. 10) Node A can sign the message A needs to get to 01, therefore uses 00 (its neighbour) as a hop. The source is a ManagedNode A therefore it does not need to receive Q before it go on its journey. Neighbours are sections with 1 change in the prefix. For example, in this instance, 00 is a neighbour of 10, as is 00 is a neighbour of 01. (destination). 01 and 10 are not neighbours as 2 changes are needed in the digits. This example, section 11 is ignored as its not required to travserve In 00, A identifies C as its closest in hash. PS::sigs (A4, Q of A4 sign A5), forward proofs PS::sigs (A3, Q of A3 sign A4), PS::sigs (A2, Q of A2 sign A3), PS::successor(A3), reverse proof PS::successor(A4), PS::successor(A5) A then sends \u201cM + meta info\u201d to C Pfx-10 { /* Nodes: A(was added in A4) .. */ - Our-Infos: A1,A2,A3,A4,A5 - Their-Knowledge: 00-A2, 11-A4 - Neighbour-Infos: 11(B3)-A3, 10(C4)-A2 } A knows from Their_Know that 00 knows up to A2. A therefore attaches signatures up to A2 & successors up it its latest version, A5 so it can make sure the most up to date V is sent over. HOP The message now is with C C trims from the bottom to the top until it gets to where it trusts (A3) PS::sigs (A4, Q of A4 sign A5), PS::sigs (A3, Q of A3 sign A4) PS:: successors (A3) C can then relay this as it trusts up to A3 Pfx-00 { /* Nodes: C(was added in C3) .. */ - Our-Infos: C1,C2,C3,C4,C5 - Their-Knowledge: 01-C2, 10-C3 - Neighbour-Infos: 10(A3)-C1, 01(D4)-C3 In the Neigh_Info, we see that C knows about up to A3 in section 10 (the previous section from where the message came from) . By removing the excess (trimming) the message ready to send. Trimming removes the unnecessary information, he only needs up to what he trusts. Ask, do i trust (Y/n) keep going to I trust dont need to go any further C calculates the next hop as D in 01 (the destination. PS::sigs (A4, Q of A4 sign A5), PS::sigs (A3, Q of A3 sign A4), PS:: successors (A3) PS::sigs (C1, Q of C1 sign A3) PS:: successor (C2) PS:: successor (C3) PS:: successor (C4) PS:: successor (C5) We can now relay to D in 01 Pfx-00 { /* Nodes: C(was added in C3) .. */ - Our-Infos: C1,C2,C3,C4,C5 - Their-Knowledge: 01-C2, 10-C3 - Neighbour-Infos: 10(A3)-C1, 01(D4)-C3 We know that A3 has been signed by C1 from the Neigh_info in the network set up In this section we know up to C5 so we must add in Successors up to that version however they know up to C2 so that must be included, so up to their knowledge and current versions. HOP The message is now in D D trims to the point it trusts PS::sigs (A4, Q of A4 sign A5), PS::sigs (A3, Q of A3 sign A4), PS:: successors (A3) PS::sigs (C1, Q of C1 sign A3) PS:: successor (C2) PS:: successor (C3) D now has the following info: M { src: MN(A) dst: PfxSec(01) content: \u201cBye\u201d } meta-info A5 src_section: sigs from Q of A5 for M (add in prf to add the sec info) sigs_of_msg: PS::sigs (A4, Q of A4 sign A5), PS::sigs (A3, Q of A3 sign A4), PS:: successors (A3) PS::sigs (C1, Q of C1 sign A3) PS:: successor (C2) PS:: successor (C3) } Validation: C3 is known C3 is the successor of C2 C2 is the successor of C1 A3 is signed by Q of C1 C1 signs A3 A3 signs A4 A4 signs A5 A5 is the src_section which signed the message M D swarms the message to all in Pfx. 01 Pfx-01 { /* Nodes: D(was added in D4) .. */ - Our-Infos: D1,D2,D3,D4,D5 - Their-Knowledge: 00-D3, 11-D3 - Neighbour-Infos: 00(C3)-D2, 11(B4)-D4 D knows up to C3 from the previous section By going through the validation process, starting from the bottom, it checks it has all the relevant info to be able to trust the message. D can trust the message M is genuine and from a genuine source section 10 Swarm this section as the destination is labeled as 01, so all nodes need the message Features Validation at the point of destination to ensure the meta info is correct and therefore is trustworthy Digital signatures Quorum Routes Benefits It is a secure way to make sure only non-malicious communications are being sent across a dynamic network","title":"Message Relay & SMR"},{"location":"05_messaging/#message-relay-smr","text":"","title":"Message Relay &amp; SMR"},{"location":"05_messaging/#summary","text":"Sending and / or receiving a new message from a source to a destination","title":"Summary"},{"location":"05_messaging/#status","text":"Message relay - Alpha 2 / SMR - Fleming","title":"Status"},{"location":"05_messaging/#how-it-works","text":"","title":"How it works"},{"location":"05_messaging/#traversal-logic","text":"While nodes only maintain an awareness of their neighbouring nodes, and connect when necessary, if a message needs to travel across the network out with its neighbouring nodes, how do messages reach their destination? The current mechanism is passing a message between two distant sections relies on a chain of relay nodes, one per section, across the network. All of the relaying nodes then pass the message to all of the relaying nodes in the next hop (jumping across sections) making it certain that the message will make it to the recipient, For a node to message another node, the source node needs to know the destination nodes address, which also indicates the prefix section it\u2019s in. If the source can\u2019t send directly to the destination, it identifies the closest prefix possible from it's knowledge of neighbouring sections. So in the first example below (the first box) the source node (MN) is in prefix 1111 and wants to send to the destination node in prefix 0000. Because it can\u2019t send it directly, source node identifies that it\u2019s neighbour (111) is the next closest to the destination. The message is sent from 1111 111 (first hop). Then the process starts again. Section 111, if can\u2019t send directly to the destination, it identifies the closest prefix possible from it's knowledge of neighbouring sections (it\u2019s neighbouring sections are 011, 101, 110). 111 therefore sends to 011 (second hop). The process repeats. Section 011 looks at its neighbours (001, 010, 111) and identifies 001 as the next closet (third hop). Finally 001 is able to send the message to 000 (final hop to destination) and on to the destination node itself. Using the same logic, you can see how a message is sent from a section to a section (2nd box) and also from a group to another group (3rd box). But why do we need messages to be sent to three different types of destinations? To expand, we\u2019ve listed out a few example scenarios for when a particular destination type is used: Send to a node - only concerns that node Send to a section - accepting a new node into the section Send to a group - storing a piece of data By using this logic, we can now understand message relay.","title":"Traversal Logic:"},{"location":"05_messaging/#message-relay","text":"We\u2019ll run through an example to help us understand message relay. Here we are sending a node (A) in section 00 to a node (X) in section 11. When any node tries to send a message, it must first accumulate information that is required to send the message (hence it\u2019s called the Accumulating Node). In addition to the message, it also has to have a quorum of signatures from the other nodes in its Section to confirm that it is validly allowed to send a message. That quorum is defined as a simple majority of nodes in a Section (so in this example, there are 6 nodes. If B C signs it, it reaches quorum. By getting a Quorum of signatures, it proves that it is a trusted sender in the eyes of the Network. If the node did not have a quorum of signatures from its Section, it would simply be an untrusted message as you can\u2019t trust a single node (which could be malicious). A now has a quorum of its signatures. A being in Section 00 identifies its neighbour as 10. In that Section, node is passed the message to G as it's closest to the hash to the message. G now has it. This is classed as a \u2018hop\u2019. Once it is as G in Section 10, she now identifies her neighbour as 11 where is where the destination X lives. This is passed over and now with message relay is complete. As you see Section 01 is greyed out. This is because the message doesn't need to traverse to that section to get to its destination. Messages that traverse the Alpha 2 Network currently don\u2019t require a quorum of signatures. This means that any malicious node could generate fictitious keypair identities for nodes that it claims are valid nodes in Sections further back in the message chain - and the recipient would have no way of checking this. In the above example as 11 does not know 00 they are not aware of the member list of 00. Therefore, G could create false key pairs which look like nodes from section 00 (ie with the prefix 00). G could send a message to X claiming it was from A and X has no way to validate this. Secure message relay mitigates this as a quorum of 01 will have signed the member list of 00 and these signatures will be attached to the message. As X knows and trust the members of 01 their signatures on the membership of 00 provides validity to the message coming from a true A. We\u2019ll now go into this in more detail.","title":"Message Relay"},{"location":"05_messaging/#secure-message-relay-smr","text":"So Secure Message Relay in Fleming gives the SAFE Network a way of ensuring that any messages sent across isolated parts of the Network (via hops through Neighbours) can be verified as trustworthy - enabling the Network to scale infinitely without weakening the trust requirements. This is not a problem that any other project today has been able to solve (as far as we are aware). In simple terms: SMR simply a chain of trust / validating the senders (not the message) Before we go any further we\u2019ll discuss Accumulation and Routes briefly.","title":"Secure Message Relay (SMR)"},{"location":"05_messaging/#accumulation","text":"Each message requires a quorum of signatures in order that it can be trusted by the recipient. There are two options here on quorum: Accumulating at source = collating at source Accumulating at destination = collating at destination In the Network we use the first option as it takes less messages and is more efficient. Here is an example: As you can see, the accumulation at source is a simpler route with less messages and is more efficient. The accumulation at destination, the network is firing messages through any means possible in hope one lands and is acknowledged by the destination node.","title":"Accumulation:"},{"location":"05_messaging/#routes","text":"How do the nodes know they have the correct message? Let\u2019s use another example. The message sender is Section 00 and A is the accumulating node. The next step is G which is determined by which node is closest (XOR) to the hash of the message. Closeness to a hash is used to balance load across the network. To avoid a single point of failure, the source will send a message to a destination and they will wait for an ACK. ACK (acknowledgement) is quorum at the destination that the message has got through. If the source does not receive an ACK within a given time frame, the source will keep trying until one is received. Routing of messages on SAFE is subject to time limits to ensure the Network is working as intended and to ensure that false messages are not transferred. You can't lie about receiving an ACK. If they don't get an ACK, the section will choose another node and different route. In the example below, the blue line represents the first route however no ACK was received. As the ranking is defined by XOR, the 2nd attempt on route 2 is then defined on the 2nd closest XOR in each section. This process continues until an ACK is received.","title":"Routes:"},{"location":"05_messaging/#routes-convergence","text":"This is when routes are happening in different hops. This example above is Section 00 sending a message to Section 11. A is the accumulating node and sending it through D. However, D in Section 01 is malicious and doesn't send the message to the given destination 11. However in a network of disjoint sections we have churn. So the nodes are not static in each section. So in the example below, Section 01 has receieved a new node X. The next Node, B, then tries to send the message again but as now X is first in the list so it hits D again.","title":"Routes Convergence:"},{"location":"05_messaging/#secure-message-relay","text":"Each time a section performs churn they notify their neighbours of any updates to their section info. Once a neighbour has the new info each member performs validations on this change, passes it through PARSEC and signs the PARSEC event. Quorum needs to be reached, then these signed events are attached the neighbour info. When a single node is sending a messages this signed neighbour info is attached so the destination can validate the sender even though they are not neighbours. This info includes the signatures of known and trusted nodes as well as the key pairs of the sender (in this example) this means no node along the journey can falsify the message or its sender. Our info: what we know in our section Their Knowledge: what your neighbours know about you as far as we know Neighbour info: what we know about our neighbours Successors Successors are added to the meta-info, to show the sequence of section versions from the version indicated in TheirInfo and the current version. This is done in case the neighbours have a differing version of our section than the sending section believes This is best explained through an example, please see below: Network set up This is the given network set up. ``` Pfx-10 { /* Nodes: A(was added in A4) .. */ - Our-Infos: A1,A2,A3,A4,A5 - Their-Knowledge: 00-A2, 11-A4 - Neighbour-Infos: 11(B3)-A3, 10(C4)-A2 } Pfx-11 { /* Nodes: B(was added in B2) .. */ - Our-Infos: B1,B2,B3,B4 - Their-Knowledge: 10-B2, 01-B3 - Neighbour-Infos: 10(A5)-B3, 01(D4)-B3 } Pfx-00 { /* Nodes: C(was added in C3) .. */ \u0002wzxhzdk:0\u0003 |sds | This is the given network set up. Here we can see we have 4 Prf. Sections with nodes A, B, C & D. If we take PrfSec 10, we see the nodes is A and was added when they were at version A4. In our section 10, we know that we\u2019re on A5. Our neighbours 00 know we\u2019re on A2 & 11 A4. You can see they don't have the most up to date information and this is due to churn. We know we signed B3 in Section 11 and C4 in 10. Q: Quorum PS: ProvingSections M: Message M { src: MN(A) dst: PfxSec(01) content: \u201cBye\u201d } meta-info { src_section: None sigs_of_msg: None PS: Empty } Here is the message. So the src (source) is a MN (managednode) A. We know A is in PfxSec 10. Dst (destination) is were the node is going. In this instance it's going to PrxSec 01. This example means we\u2019re going from a ManagedNode to a section. The meta info is empty at the moment. Start at A (prf. 10) Node A can sign the message A needs to get to 01, therefore uses 00 (its neighbour) as a hop. The source is a ManagedNode A therefore it does not need to receive Q before it go on its journey. Neighbours are sections with 1 change in the prefix. For example, in this instance, 00 is a neighbour of 10, as is 00 is a neighbour of 01. (destination). 01 and 10 are not neighbours as 2 changes are needed in the digits. This example, section 11 is ignored as its not required to travserve In 00, A identifies C as its closest in hash. PS::sigs (A4, Q of A4 sign A5), forward proofs PS::sigs (A3, Q of A3 sign A4), PS::sigs (A2, Q of A2 sign A3), PS::successor(A3), reverse proof PS::successor(A4), PS::successor(A5) A then sends \u201cM + meta info\u201d to C Pfx-10 { /* Nodes: A(was added in A4) .. */ - Our-Infos: A1,A2,A3,A4,A5 - Their-Knowledge: 00-A2, 11-A4 - Neighbour-Infos: 11(B3)-A3, 10(C4)-A2 } A knows from Their_Know that 00 knows up to A2. A therefore attaches signatures up to A2 & successors up it its latest version, A5 so it can make sure the most up to date V is sent over. HOP The message now is with C C trims from the bottom to the top until it gets to where it trusts (A3) PS::sigs (A4, Q of A4 sign A5), PS::sigs (A3, Q of A3 sign A4) PS:: successors (A3) C can then relay this as it trusts up to A3 Pfx-00 { /* Nodes: C(was added in C3) .. */ - Our-Infos: C1,C2,C3,C4,C5 - Their-Knowledge: 01-C2, 10-C3 - Neighbour-Infos: 10(A3)-C1, 01(D4)-C3 In the Neigh_Info, we see that C knows about up to A3 in section 10 (the previous section from where the message came from) . By removing the excess (trimming) the message ready to send. Trimming removes the unnecessary information, he only needs up to what he trusts. Ask, do i trust (Y/n) keep going to I trust dont need to go any further C calculates the next hop as D in 01 (the destination. PS::sigs (A4, Q of A4 sign A5), PS::sigs (A3, Q of A3 sign A4), PS:: successors (A3) PS::sigs (C1, Q of C1 sign A3) PS:: successor (C2) PS:: successor (C3) PS:: successor (C4) PS:: successor (C5) We can now relay to D in 01 Pfx-00 { /* Nodes: C(was added in C3) .. */ - Our-Infos: C1,C2,C3,C4,C5 - Their-Knowledge: 01-C2, 10-C3 - Neighbour-Infos: 10(A3)-C1, 01(D4)-C3 We know that A3 has been signed by C1 from the Neigh_info in the network set up In this section we know up to C5 so we must add in Successors up to that version however they know up to C2 so that must be included, so up to their knowledge and current versions. HOP The message is now in D D trims to the point it trusts PS::sigs (A4, Q of A4 sign A5), PS::sigs (A3, Q of A3 sign A4), PS:: successors (A3) PS::sigs (C1, Q of C1 sign A3) PS:: successor (C2) PS:: successor (C3) D now has the following info: M { src: MN(A) dst: PfxSec(01) content: \u201cBye\u201d } meta-info A5 src_section: sigs from Q of A5 for M (add in prf to add the sec info) sigs_of_msg: PS::sigs (A4, Q of A4 sign A5), PS::sigs (A3, Q of A3 sign A4), PS:: successors (A3) PS::sigs (C1, Q of C1 sign A3) PS:: successor (C2) PS:: successor (C3) } Validation: C3 is known C3 is the successor of C2 C2 is the successor of C1 A3 is signed by Q of C1 C1 signs A3 A3 signs A4 A4 signs A5 A5 is the src_section which signed the message M D swarms the message to all in Pfx. 01 Pfx-01 { /* Nodes: D(was added in D4) .. */ - Our-Infos: D1,D2,D3,D4,D5 - Their-Knowledge: 00-D3, 11-D3 - Neighbour-Infos: 00(C3)-D2, 11(B4)-D4 D knows up to C3 from the previous section By going through the validation process, starting from the bottom, it checks it has all the relevant info to be able to trust the message. D can trust the message M is genuine and from a genuine source section 10 Swarm this section as the destination is labeled as 01, so all nodes need the message Features Validation at the point of destination to ensure the meta info is correct and therefore is trustworthy Digital signatures Quorum Routes Benefits It is a secure way to make sure only non-malicious communications are being sent across a dynamic network","title":"Secure Message Relay"},{"location":"06_chain/","text":"Chain","title":"Chain"},{"location":"06_chain/#chain","text":"","title":"Chain"},{"location":"07_parsec/","text":"PARSEC","title":"PARSEC"},{"location":"07_parsec/#parsec","text":"","title":"PARSEC"},{"location":"08_ageing/","text":"Node Ageing","title":"Node Ageing"},{"location":"08_ageing/#node-ageing","text":"","title":"Node Ageing"}]}
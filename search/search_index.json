{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SAFE Fleming Bible This is a document that allows anyone in marketing to speak intelligently about Fleming, what it is and what it delivers at a technical level. This will be an iterative document, where we will add and amend as we learn and understand more about the Network. To ensure this is kept up-to-date, a version control log has been added so we can track on changes. Contents Glossary Sharding / Disjoint Sections Authorities Groups Sections Message Relay Secure Message Relay Chain PARSEC Node Ageing Version Log Version # Who Summary of changes Date v2 Ceilidh Changes based on TL feedback PARSEC added 15/04/2019 - TBC","title":"SAFE Fleming Bible"},{"location":"#safe-fleming-bible","text":"This is a document that allows anyone in marketing to speak intelligently about Fleming, what it is and what it delivers at a technical level. This will be an iterative document, where we will add and amend as we learn and understand more about the Network. To ensure this is kept up-to-date, a version control log has been added so we can track on changes.","title":"SAFE Fleming Bible"},{"location":"#contents","text":"Glossary Sharding / Disjoint Sections Authorities Groups Sections Message Relay Secure Message Relay Chain PARSEC Node Ageing","title":"Contents"},{"location":"#version-log","text":"Version # Who Summary of changes Date v2 Ceilidh Changes based on TL feedback PARSEC added 15/04/2019 - TBC","title":"Version Log"},{"location":"01_glossary/","text":"Glossary A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z A ABFT Asynchronous Byzantine Fault Tolerance Accumulating Node The node that collates the message and signatures before sending when the sending authority is multiple Accumulation at Source When proofs are accumulated at the source of a message rather than the destination Ack Acknowledgement, confirmation that a message has been received successfully Appendable data Ability to append information to an existing piece of data, you cannot change what already exists. Authority A label that is applied to any message that determines its ultimate destination Autonomous The ability for the network to manage data without human intervention B Bootstrapping A process to join the network. Anything that joins the network has to go through the Bootstrapping process Buffer Nodes additional to the minimum group size that are required before a split can occur to reduce merges. C Chain Links that couple together identifiers (descriptors) Client Individual computers CRUST C ommunications in Rust : It\u2019s a generic networking library that essentially connects two nodes/peers/computers directly without an intermediate server D Disjoint Section A group of Vaults defined by their XOR address prefix G Gossip Event A Gossip Event is any piece of information that is sent across the Network using the Gossip protocol. Group 8 Nodes with a close XOR address H Hop Hop is when you have to travel through neighbouring Sections in the network to reach your destination. I Invariant A set of rules which enable the Network to maintain a stable state Immutable data A data type that cannot be changed, and whose location is determined by the hash of the data itself. M Merge Merges happen when there are too few nodes (below minimum group size) in a Section so the nodes \u2018merge\u2019 with another Section. You can only merge with a sibling. Message in this context it\u2019s any network operation (gossiping messages, relay messages, new node joining, consensus) N Neighbour relations to sections determined by the Network Invariant . Neighbours are those sections which prefix differ by one bit, i.e the neighbour of \u201801\u2019 is \u201811\u2019 and \u201800\u2019, \u201810\u2019 is not a neighbour as you have to change both the \u20180\u2019 and the \u20181\u2019 (bits). Network Event Nodes attempt to communicate \u2018truths\u2019 to each other on the network Node individual device on the network Node age an autonomous and decentralised node reputation system that ranks nodes based on their age. P PARSEC Protocol for Asynchronous, Reliable, Secure and Efficient Consensus an algorithm that orders section votes. Prefix first numbers (bits) at the beginning of the XOR address Proxy Acts as an intermediary between the client and the network / single authority Q Quorum quorum is the minimum number needed to cast a vote before an action can take place R Resource proof CPU, reliability bandwidth, features a new node needs to prove on a continuous basis S Secure Message Relay a way of validating the senders of messages (not the messages) across Disjoint Sections of the Network. Section is a subset of all the addresses on the network. Section info an object that has info on the section including prefix, version, members - public identity (public key and encryption key), previous hash, hash Sharding The process by which sections change size, the location of responsibility and often their Neighbours due to splits and merges. Sibling are a special case of neighbours, siblings prefixes differ by only 1 bit at the very last bit. In the example above 01 would be the sibling to 00. Siblings are of particular importance in the case of mergers Split split occurs in a section when the section gets too big and unbalanced. Swarm the process by which one node in a Section shares a received message with every other node in that Section V Vault Vector list Version the members of a section at a given point in time. X XOR Every node or piece of data in the Network has a XOR address, which is a 256-bit long identifier","title":"Glossary"},{"location":"01_glossary/#glossary","text":"A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z","title":"Glossary"},{"location":"01_glossary/#a","text":"","title":"A"},{"location":"01_glossary/#abft","text":"Asynchronous Byzantine Fault Tolerance","title":"ABFT"},{"location":"01_glossary/#accumulating-node","text":"The node that collates the message and signatures before sending when the sending authority is multiple","title":"Accumulating Node"},{"location":"01_glossary/#accumulation-at-source","text":"When proofs are accumulated at the source of a message rather than the destination","title":"Accumulation at Source"},{"location":"01_glossary/#ack","text":"Acknowledgement, confirmation that a message has been received successfully","title":"Ack"},{"location":"01_glossary/#appendable-data","text":"Ability to append information to an existing piece of data, you cannot change what already exists.","title":"Appendable data"},{"location":"01_glossary/#authority","text":"A label that is applied to any message that determines its ultimate destination","title":"Authority"},{"location":"01_glossary/#autonomous","text":"The ability for the network to manage data without human intervention","title":"Autonomous"},{"location":"01_glossary/#b","text":"","title":"B"},{"location":"01_glossary/#bootstrapping","text":"A process to join the network. Anything that joins the network has to go through the Bootstrapping process","title":"Bootstrapping"},{"location":"01_glossary/#buffer","text":"Nodes additional to the minimum group size that are required before a split can occur to reduce merges.","title":"Buffer"},{"location":"01_glossary/#c","text":"","title":"C"},{"location":"01_glossary/#chain","text":"Links that couple together identifiers (descriptors)","title":"Chain"},{"location":"01_glossary/#client","text":"Individual computers","title":"Client"},{"location":"01_glossary/#crust","text":"C ommunications in Rust : It\u2019s a generic networking library that essentially connects two nodes/peers/computers directly without an intermediate server","title":"CRUST"},{"location":"01_glossary/#d","text":"","title":"D"},{"location":"01_glossary/#disjoint-section","text":"A group of Vaults defined by their XOR address prefix","title":"Disjoint Section"},{"location":"01_glossary/#g","text":"","title":"G"},{"location":"01_glossary/#gossip-event","text":"A Gossip Event is any piece of information that is sent across the Network using the Gossip protocol.","title":"Gossip Event"},{"location":"01_glossary/#group","text":"8 Nodes with a close XOR address","title":"Group"},{"location":"01_glossary/#h","text":"","title":"H"},{"location":"01_glossary/#hop","text":"Hop is when you have to travel through neighbouring Sections in the network to reach your destination.","title":"Hop"},{"location":"01_glossary/#i","text":"","title":"I"},{"location":"01_glossary/#invariant","text":"A set of rules which enable the Network to maintain a stable state","title":"Invariant"},{"location":"01_glossary/#immutable-data","text":"A data type that cannot be changed, and whose location is determined by the hash of the data itself.","title":"Immutable data"},{"location":"01_glossary/#m","text":"","title":"M"},{"location":"01_glossary/#merge","text":"Merges happen when there are too few nodes (below minimum group size) in a Section so the nodes \u2018merge\u2019 with another Section. You can only merge with a sibling.","title":"Merge"},{"location":"01_glossary/#message","text":"in this context it\u2019s any network operation (gossiping messages, relay messages, new node joining, consensus)","title":"Message"},{"location":"01_glossary/#n","text":"","title":"N"},{"location":"01_glossary/#neighbour","text":"relations to sections determined by the Network Invariant . Neighbours are those sections which prefix differ by one bit, i.e the neighbour of \u201801\u2019 is \u201811\u2019 and \u201800\u2019, \u201810\u2019 is not a neighbour as you have to change both the \u20180\u2019 and the \u20181\u2019 (bits).","title":"Neighbour"},{"location":"01_glossary/#network-event","text":"Nodes attempt to communicate \u2018truths\u2019 to each other on the network","title":"Network Event"},{"location":"01_glossary/#node","text":"individual device on the network","title":"Node"},{"location":"01_glossary/#node-age","text":"an autonomous and decentralised node reputation system that ranks nodes based on their age.","title":"Node age"},{"location":"01_glossary/#p","text":"","title":"P"},{"location":"01_glossary/#parsec","text":"Protocol for Asynchronous, Reliable, Secure and Efficient Consensus an algorithm that orders section votes.","title":"PARSEC"},{"location":"01_glossary/#prefix","text":"first numbers (bits) at the beginning of the XOR address","title":"Prefix"},{"location":"01_glossary/#proxy","text":"Acts as an intermediary between the client and the network / single authority","title":"Proxy"},{"location":"01_glossary/#q","text":"","title":"Q"},{"location":"01_glossary/#quorum","text":"quorum is the minimum number needed to cast a vote before an action can take place","title":"Quorum"},{"location":"01_glossary/#r","text":"","title":"R"},{"location":"01_glossary/#resource-proof","text":"CPU, reliability bandwidth, features a new node needs to prove on a continuous basis","title":"Resource proof"},{"location":"01_glossary/#s","text":"","title":"S"},{"location":"01_glossary/#secure-message-relay","text":"a way of validating the senders of messages (not the messages) across Disjoint Sections of the Network.","title":"Secure Message Relay"},{"location":"01_glossary/#section","text":"is a subset of all the addresses on the network.","title":"Section"},{"location":"01_glossary/#section-info","text":"an object that has info on the section including prefix, version, members - public identity (public key and encryption key), previous hash, hash","title":"Section info"},{"location":"01_glossary/#sharding","text":"The process by which sections change size, the location of responsibility and often their Neighbours due to splits and merges.","title":"Sharding"},{"location":"01_glossary/#sibling","text":"are a special case of neighbours, siblings prefixes differ by only 1 bit at the very last bit. In the example above 01 would be the sibling to 00. Siblings are of particular importance in the case of mergers","title":"Sibling"},{"location":"01_glossary/#split","text":"split occurs in a section when the section gets too big and unbalanced.","title":"Split"},{"location":"01_glossary/#swarm","text":"the process by which one node in a Section shares a received message with every other node in that Section","title":"Swarm"},{"location":"01_glossary/#v","text":"","title":"V"},{"location":"01_glossary/#vault","text":"","title":"Vault"},{"location":"01_glossary/#vector","text":"list","title":"Vector"},{"location":"01_glossary/#version","text":"the members of a section at a given point in time.","title":"Version"},{"location":"01_glossary/#x","text":"","title":"X"},{"location":"01_glossary/#xor","text":"Every node or piece of data in the Network has a XOR address, which is a 256-bit long identifier","title":"XOR"},{"location":"02_sharding/","text":"Sharding / Disjoint Sections Summary Strategy used to scale a Network by distributing the load between \"shards\" where each \"shard\" is only responsible for part of the Network's functioning. In the SAFE Network, Disjoint Sections act as shards which is process by which sections change size, the location of responsibility and often their Neighbours due to splits and merges. Splits Triggered by a new node joining Split is the process by which a section makes a binary split into two smaller sections. Splits only occur once certain factors have been met: There must be a minimum group size for each child Plus a buffer Splits are a valid loss of information, neighbours and responsibility for a node Merges If the nodes in a Section fall below the \u2018MinimumGroupSize\u2019, the nodes of one Section will merge with their sibling. Merges lead to an increase in area of responsibility. Status Present in Alpha 2 / unique to Safe How it works Before we get into Sections, we\u2019ll just briefly touch upon bootstrapping - When a node first joins, it contacts a proxy - That proxy sends the node to a Section which asks the newcomer to generate a new public/private keypair within a specified range that is covered by that Section. - This is different to Bitcoin for SAFE, the ID generation is random, but still defined to a given range. BTC generated at random not within range. - The new node now has a Public Signing Key which doubles as its XOR address on the Network. Nadia Burborough: 'Public Signing Key' at what point do the encryption key pairs get generated? Sarah Pentland: I don't know the answer to this one, need dev team help here Sections A subset of all the addresses on the Network. The Network is a 32 byte or 256 bit range of addresses. 256 bit = 2 to the power of 256 possible combinations (78 digits) The Network Invariant specified for Disjoint sections: - Each prefix is responsible for part of the network, a node cannot be in more than 1 Section (unlike a Group) - No overlap because the Section is defined by the node\u2019s prefix - So a node that has a prefix 11001\u2026 will be in that Section - it cannot be in e.g. Section 10101 Neighbours Are Sections that have a prefix which differs from their own prefix by one single bit. In the example of: 00, 01, 10, 11 (which covers the whole network space) 00\u2019s neighbours are 01 and 10 only. 11 does not count as a Neighbour (as the prefix differs by 2 bits). Once you identify a Section as your neighbour, they also identify you as their Neighbour. Siblings Are a special subset of Neighbours. Siblings have prefixes that differ by only 1 bit at the very last bit. In the example above, 01 would be the sibling to 00. Siblings are crucial for merges. If no Sibling exists when a merge is required, the Sections would have to collapse/merge until a Sibling is created (i.e. the tree collapses upwards until it ends up with a Section whose prefix differs by only the last bit). Splitting Splits involve a binary split of one disjoint section into two sibling disjoint sections. Involves a valid loss of information from a node as it becomes part of a different section which are responsible for a smaller XOR space Don't require an external source of trust as they got enough information from the section they used to be a member of. (As opposed to merges where you need to gain info from your sibling and establish trust in the process) Removing a node will never trigger a disjoint section to split Split mechanism A split may occur when a node joins the section. In order for a split to occur there must be a minimum number (8 - current group size) of peers and a buffer for each child. The buffer is required to reduce the likelihood of a re-merge as these are expensive/resource intensive network activities. As there is continual node loss and churn. The buffer is required to minimise merge events being triggered as a result of a node or two disconnecting. We do not want too many merges as they are resource heavy. All prefix changes are Network expensive. Splits do not need to happen immediately as unlike mergers there is no risk of data loss, so these can be a key area for Network throttle. An unbalanced section can split into more than one child on one side. This is known as a multi-split. I.e. 01 would split into 010 and 111. This would occur if there was a very large number of nodes with the prefix 11 and as soon as the split into 10 and 11 occurs there is already enough to split into 110 and 111. A split represents a valid loss of information. Nodes from a splitting section will be responsible for less information following a split, as they are now responsible for a smaller section of the Network. This will not be not in Fleming but will be included in Maxwell as there is no data in Fleming This has benefits to scalability and performance, as the Network grows sections are responsible for less rather than other models in which the greater the information the slower Splits lead to the loss of neighbours Merging Are far more complicated than splits as sections gain information. The merging sections must be able to trust the previously responsible section for all the information. Two disjoint sections are merged when one of the siblings membership falls below the minimum group size. A Merge will result in a gain of information Removing a node may trigger the merge of two disjoint sections Merges are computationally expensive for the Network - as they require nodes to gain new information (which they need to validate in order to trust it) and responsibilities. It also means that the Nodes\u2019 prefix will change when they form a new Section Note: post-Fleming, when we have data, the load on the Network will increase, which can impact performance A merge must happen immediately to ensure that data is not inaccessible Features Bootstrapping When a new node joins the Network, it will contact a proxy node. That proxy directs the node to a Section. That Section will then require the new node to generate a Public Signing Key(pair) that is within a specified range (i.e. the range that Section covers). Once it has done this, its functionality will then be tested (via Resource Proof - i.e. does it have the necessary bandwidth etc). Balanced Relocation When a new node requests to join a section, the section will look at the identities of the existing members and in order to ensure balance in the event of a split. Splits A split occurs in a section when the section gets too big and unbalanced. Merge Merges happen when there are too few nodes (below minimum group size) in a Section so the nodes \u2018merge\u2019 with another Section. You can only merge with a sibling. Benefits Scalability","title":"Sharding / Disjoint Sections"},{"location":"02_sharding/#sharding-disjoint-sections","text":"","title":"Sharding / Disjoint Sections"},{"location":"02_sharding/#summary","text":"Strategy used to scale a Network by distributing the load between \"shards\" where each \"shard\" is only responsible for part of the Network's functioning. In the SAFE Network, Disjoint Sections act as shards which is process by which sections change size, the location of responsibility and often their Neighbours due to splits and merges.","title":"Summary"},{"location":"02_sharding/#splits","text":"Triggered by a new node joining Split is the process by which a section makes a binary split into two smaller sections. Splits only occur once certain factors have been met: There must be a minimum group size for each child Plus a buffer Splits are a valid loss of information, neighbours and responsibility for a node","title":"Splits"},{"location":"02_sharding/#merges","text":"If the nodes in a Section fall below the \u2018MinimumGroupSize\u2019, the nodes of one Section will merge with their sibling. Merges lead to an increase in area of responsibility.","title":"Merges"},{"location":"02_sharding/#status","text":"Present in Alpha 2 / unique to Safe","title":"Status"},{"location":"02_sharding/#how-it-works","text":"Before we get into Sections, we\u2019ll just briefly touch upon bootstrapping - When a node first joins, it contacts a proxy - That proxy sends the node to a Section which asks the newcomer to generate a new public/private keypair within a specified range that is covered by that Section. - This is different to Bitcoin for SAFE, the ID generation is random, but still defined to a given range. BTC generated at random not within range. - The new node now has a Public Signing Key which doubles as its XOR address on the Network. Nadia Burborough: 'Public Signing Key' at what point do the encryption key pairs get generated? Sarah Pentland: I don't know the answer to this one, need dev team help here","title":"How it works"},{"location":"02_sharding/#sections","text":"A subset of all the addresses on the Network. The Network is a 32 byte or 256 bit range of addresses. 256 bit = 2 to the power of 256 possible combinations (78 digits) The Network Invariant specified for Disjoint sections: - Each prefix is responsible for part of the network, a node cannot be in more than 1 Section (unlike a Group) - No overlap because the Section is defined by the node\u2019s prefix - So a node that has a prefix 11001\u2026 will be in that Section - it cannot be in e.g. Section 10101","title":"Sections"},{"location":"02_sharding/#neighbours","text":"Are Sections that have a prefix which differs from their own prefix by one single bit. In the example of: 00, 01, 10, 11 (which covers the whole network space) 00\u2019s neighbours are 01 and 10 only. 11 does not count as a Neighbour (as the prefix differs by 2 bits). Once you identify a Section as your neighbour, they also identify you as their Neighbour.","title":"Neighbours"},{"location":"02_sharding/#siblings","text":"Are a special subset of Neighbours. Siblings have prefixes that differ by only 1 bit at the very last bit. In the example above, 01 would be the sibling to 00. Siblings are crucial for merges. If no Sibling exists when a merge is required, the Sections would have to collapse/merge until a Sibling is created (i.e. the tree collapses upwards until it ends up with a Section whose prefix differs by only the last bit).","title":"Siblings"},{"location":"02_sharding/#splitting","text":"Splits involve a binary split of one disjoint section into two sibling disjoint sections. Involves a valid loss of information from a node as it becomes part of a different section which are responsible for a smaller XOR space Don't require an external source of trust as they got enough information from the section they used to be a member of. (As opposed to merges where you need to gain info from your sibling and establish trust in the process) Removing a node will never trigger a disjoint section to split","title":"Splitting"},{"location":"02_sharding/#split-mechanism","text":"A split may occur when a node joins the section. In order for a split to occur there must be a minimum number (8 - current group size) of peers and a buffer for each child. The buffer is required to reduce the likelihood of a re-merge as these are expensive/resource intensive network activities. As there is continual node loss and churn. The buffer is required to minimise merge events being triggered as a result of a node or two disconnecting. We do not want too many merges as they are resource heavy. All prefix changes are Network expensive. Splits do not need to happen immediately as unlike mergers there is no risk of data loss, so these can be a key area for Network throttle. An unbalanced section can split into more than one child on one side. This is known as a multi-split. I.e. 01 would split into 010 and 111. This would occur if there was a very large number of nodes with the prefix 11 and as soon as the split into 10 and 11 occurs there is already enough to split into 110 and 111. A split represents a valid loss of information. Nodes from a splitting section will be responsible for less information following a split, as they are now responsible for a smaller section of the Network. This will not be not in Fleming but will be included in Maxwell as there is no data in Fleming This has benefits to scalability and performance, as the Network grows sections are responsible for less rather than other models in which the greater the information the slower Splits lead to the loss of neighbours","title":"Split mechanism"},{"location":"02_sharding/#merging","text":"Are far more complicated than splits as sections gain information. The merging sections must be able to trust the previously responsible section for all the information. Two disjoint sections are merged when one of the siblings membership falls below the minimum group size. A Merge will result in a gain of information Removing a node may trigger the merge of two disjoint sections Merges are computationally expensive for the Network - as they require nodes to gain new information (which they need to validate in order to trust it) and responsibilities. It also means that the Nodes\u2019 prefix will change when they form a new Section Note: post-Fleming, when we have data, the load on the Network will increase, which can impact performance A merge must happen immediately to ensure that data is not inaccessible","title":"Merging"},{"location":"02_sharding/#features","text":"","title":"Features"},{"location":"02_sharding/#bootstrapping","text":"When a new node joins the Network, it will contact a proxy node. That proxy directs the node to a Section. That Section will then require the new node to generate a Public Signing Key(pair) that is within a specified range (i.e. the range that Section covers). Once it has done this, its functionality will then be tested (via Resource Proof - i.e. does it have the necessary bandwidth etc).","title":"Bootstrapping"},{"location":"02_sharding/#balanced-relocation","text":"When a new node requests to join a section, the section will look at the identities of the existing members and in order to ensure balance in the event of a split.","title":"Balanced Relocation"},{"location":"02_sharding/#splits_1","text":"A split occurs in a section when the section gets too big and unbalanced.","title":"Splits"},{"location":"02_sharding/#merge","text":"Merges happen when there are too few nodes (below minimum group size) in a Section so the nodes \u2018merge\u2019 with another Section. You can only merge with a sibling.","title":"Merge"},{"location":"02_sharding/#benefits","text":"Scalability","title":"Benefits"},{"location":"03_authorities/","text":"Authorities Summary The relaying of messages across the network is determined by authorities. Messages can be sent from, or to, a single node or a collection of nodes. Each message must have sender destination details. For all authorities other than PrefixSection this is a full XOR address (and Client Public ID for Client authority), for PrefixSection it is a prefix . Authorities can be thought of as address labels on an envelope which detail the destination and sender address. Status Existing feature of the SAFE Network Types of authorities Authorities can be either singular authorities (single) or group authorities (multiple nodes). This means that the message is either verified by a single node or a group of nodes. Singular authorities No verification is required from other sources in order to relay the message. - #### ManagedNode Can be the source or final destination of the message and it\u2019s address is the given node address. - #### Client Can be the source or final destination of the message. A client authority is a client connecting to the network via a proxy node. The message must specify the proxy node address and the public ID of the client. Multiple (Group) authorities In order to relay the message it must be verified by a quorum of nodes in either the section or group. Section: Section : If the destination authority is Section then all nodes within the section receive the message. If the source is Section then a quorum from the section nodes must verify the message in order to relay it. PrefixSection : If the address is defined as a prefix (rather than an XOR location), the message is received by all sections (and thus nodes) within that prefix range (the \u2018root\u2019 level prefix and all child sections of that prefix). Group: ClientManager, NodeManager, NaeManager Require quorum agreement from the group of nodes closest to the source. Examples The following are some examples of message relay from and to different authorities. Section Authority (SA) to a Managed Node (MN) The node within the section closest to the address of the destination, acts as the accumulation node (indicated in orange below) and, if the node gets verification from a quorum of the section nodes it then sends the message to the destination (indicated in red below) via section relay\u2026 ManagedNode to PrefixSection A single ManagedNode (MN) sends a message to a PrefixSection (PSA). The ManagedNode (indicated in orange below) sends the message to the destination prefix (as a Single Authority it does not require quorum agreement prior to sending). Once the prefix section receives the message it delivers the message to all nodes within the prefix. Features Group authorities Singular authorities Benefits Range of authorities enable the Network to transport communication effectively and honestly The categorisation of single versus group nodes and this determines how the message is relayed","title":"Authorities"},{"location":"03_authorities/#authorities","text":"","title":"Authorities"},{"location":"03_authorities/#summary","text":"The relaying of messages across the network is determined by authorities. Messages can be sent from, or to, a single node or a collection of nodes. Each message must have sender destination details. For all authorities other than PrefixSection this is a full XOR address (and Client Public ID for Client authority), for PrefixSection it is a prefix . Authorities can be thought of as address labels on an envelope which detail the destination and sender address.","title":"Summary"},{"location":"03_authorities/#status","text":"Existing feature of the SAFE Network","title":"Status"},{"location":"03_authorities/#types-of-authorities","text":"Authorities can be either singular authorities (single) or group authorities (multiple nodes). This means that the message is either verified by a single node or a group of nodes.","title":"Types of authorities"},{"location":"03_authorities/#singular-authorities","text":"No verification is required from other sources in order to relay the message. - #### ManagedNode Can be the source or final destination of the message and it\u2019s address is the given node address. - #### Client Can be the source or final destination of the message. A client authority is a client connecting to the network via a proxy node. The message must specify the proxy node address and the public ID of the client.","title":"Singular authorities"},{"location":"03_authorities/#multiple-group-authorities","text":"In order to relay the message it must be verified by a quorum of nodes in either the section or group.","title":"Multiple (Group) authorities"},{"location":"03_authorities/#section","text":"Section : If the destination authority is Section then all nodes within the section receive the message. If the source is Section then a quorum from the section nodes must verify the message in order to relay it. PrefixSection : If the address is defined as a prefix (rather than an XOR location), the message is received by all sections (and thus nodes) within that prefix range (the \u2018root\u2019 level prefix and all child sections of that prefix).","title":"Section:"},{"location":"03_authorities/#group-clientmanager-nodemanager-naemanager","text":"Require quorum agreement from the group of nodes closest to the source.","title":"Group: ClientManager, NodeManager, NaeManager"},{"location":"03_authorities/#examples","text":"The following are some examples of message relay from and to different authorities.","title":"Examples"},{"location":"03_authorities/#section-authority-sa-to-a-managed-node-mn","text":"The node within the section closest to the address of the destination, acts as the accumulation node (indicated in orange below) and, if the node gets verification from a quorum of the section nodes it then sends the message to the destination (indicated in red below) via section relay\u2026","title":"Section Authority (SA) to a Managed Node (MN)"},{"location":"03_authorities/#managednode-to-prefixsection","text":"A single ManagedNode (MN) sends a message to a PrefixSection (PSA). The ManagedNode (indicated in orange below) sends the message to the destination prefix (as a Single Authority it does not require quorum agreement prior to sending). Once the prefix section receives the message it delivers the message to all nodes within the prefix.","title":"ManagedNode to PrefixSection"},{"location":"03_authorities/#features","text":"Group authorities Singular authorities","title":"Features"},{"location":"03_authorities/#benefits","text":"Range of authorities enable the Network to transport communication effectively and honestly The categorisation of single versus group nodes and this determines how the message is relayed","title":"Benefits"},{"location":"04_sections/","text":"Groups Sections Summary Groups: Dictate which nodes control which data. Made up of 8 nodes based on closeness of XOR address and because of that can overlap. Sections: Govern how nodes send messages across the Network Made up of an undefined number of nodes and ordered on prefix addresses. Sections can merge and split to ensure efficient operation on the network. Status Existing feature of the Network What is a section? A section is a subset of all the addresses on the Network\u2019s 256 bit address space. Therefore a Section is responsible for a specific part of the Network as defined by an XOR location. Minimum nodes for a Section defined by \u2018MinimumSectionSize\u2019, currently this is likely to be 8 (5 sufficient for consensus and 3 for buffer) All nodes in a section will have the same prefix which also relates to the section of the network they are responsible for. Sections do not overlap and nodes can only be part of one section. This means each section is only aware of, and connected to, themselves and their neighbours. The Chain is a record of information, that can be utilised by anyone. The Chain is a single chronological list of actions that have occurred in each of the Sections. We can see our chain and parts of other (neighbours) sections chains. Neighbours to a section are determined by the network invariant. To be a Neighbour, it must have a prefix which differs by only a single bit from another node. What is a Group A Group is a group size number of nodes (8) and this is defined by their closeness to a XOR address. Unlike Sections, these can overlap and nodes can be members of a number of different Groups. The closer a node is to an address space, the more info it has about the address (similar to the knowledge of the [country, city, postcode, house address]) Security increases as Network grows and this is because each node becomes responsible for a tighter group of addresses. Nadia Burborough: 'Security increases as...' this (for me anyway) doesn't answer the reason why security is increased. What is the impact tighter groups have on security? MaidBot: beep boop beep Sections Groups How it works A new node joins the Network (via Bootstrap process) Contacts a (dumb) proxy Proxy sends new node to a Section New node has to then generate keypair that falls within range of Section addresses So if sent to Section 11010\u2026, node\u2019s address must also start with 11010... Unlike Bitcoin where any random address is created The public signing key it has created now acts as that node\u2019s new location on the Network New Section now checks new node is suitable (Resource Proof)","title":"Groups & Sections"},{"location":"04_sections/#groups-sections","text":"","title":"Groups &amp; Sections"},{"location":"04_sections/#summary","text":"","title":"Summary"},{"location":"04_sections/#groups","text":"Dictate which nodes control which data. Made up of 8 nodes based on closeness of XOR address and because of that can overlap.","title":"Groups:"},{"location":"04_sections/#sections","text":"Govern how nodes send messages across the Network Made up of an undefined number of nodes and ordered on prefix addresses. Sections can merge and split to ensure efficient operation on the network.","title":"Sections:"},{"location":"04_sections/#status","text":"Existing feature of the Network","title":"Status"},{"location":"04_sections/#what-is-a-section","text":"A section is a subset of all the addresses on the Network\u2019s 256 bit address space. Therefore a Section is responsible for a specific part of the Network as defined by an XOR location. Minimum nodes for a Section defined by \u2018MinimumSectionSize\u2019, currently this is likely to be 8 (5 sufficient for consensus and 3 for buffer) All nodes in a section will have the same prefix which also relates to the section of the network they are responsible for. Sections do not overlap and nodes can only be part of one section. This means each section is only aware of, and connected to, themselves and their neighbours. The Chain is a record of information, that can be utilised by anyone. The Chain is a single chronological list of actions that have occurred in each of the Sections. We can see our chain and parts of other (neighbours) sections chains. Neighbours to a section are determined by the network invariant. To be a Neighbour, it must have a prefix which differs by only a single bit from another node.","title":"What is a section?"},{"location":"04_sections/#what-is-a-group","text":"A Group is a group size number of nodes (8) and this is defined by their closeness to a XOR address. Unlike Sections, these can overlap and nodes can be members of a number of different Groups. The closer a node is to an address space, the more info it has about the address (similar to the knowledge of the [country, city, postcode, house address]) Security increases as Network grows and this is because each node becomes responsible for a tighter group of addresses. Nadia Burborough: 'Security increases as...' this (for me anyway) doesn't answer the reason why security is increased. What is the impact tighter groups have on security? MaidBot: beep boop beep Sections Groups","title":"What is a Group"},{"location":"04_sections/#how-it-works","text":"A new node joins the Network (via Bootstrap process) Contacts a (dumb) proxy Proxy sends new node to a Section New node has to then generate keypair that falls within range of Section addresses So if sent to Section 11010\u2026, node\u2019s address must also start with 11010... Unlike Bitcoin where any random address is created The public signing key it has created now acts as that node\u2019s new location on the Network New Section now checks new node is suitable (Resource Proof)","title":"How it works"},{"location":"05_messaging/","text":"Message Relay SMR Summary Sending and / or receiving a new message from a source to a destination Status Message relay - Alpha 2 / SMR - Fleming How it works Traversal Logic While nodes only maintain an awareness of their neighbouring nodes, and connect when necessary, if a message needs to travel across the network out with its neighbouring nodes, how do messages reach their destination? The current mechanism is passing a message between two distant sections relies on a chain of relay nodes, one per section, across the network. All of the relaying nodes then pass the message to all of the relaying nodes in the next hop (jumping across sections) making it certain that the message will make it to the recipient, For a node to message another node, the source node needs to know the destination nodes address, which also indicates the prefix section it\u2019s in. If the source can\u2019t send directly to the destination, it identifies the closest prefix possible from it's knowledge of neighbouring sections. So in the first example below (the first box) the source node (MN) is in prefix 1111 and wants to send to the destination node in prefix 0000. Because it can\u2019t send it directly, source node identifies that it\u2019s neighbour (111) is the next closest to the destination. The message is sent from 1111 111 (first hop). Then the process starts again. Section 111, if can\u2019t send directly to the destination, it identifies the closest prefix possible from it's knowledge of neighbouring sections (it\u2019s neighbouring sections are 011, 101, 110). 111 therefore sends to 011 (second hop). The process repeats. Section 011 looks at its neighbours (001, 010, 111) and identifies 001 as the next closet (third hop). Finally 001 is able to send the message to 000 (final hop to destination) and on to the destination node itself. Using the same logic, you can see how a message is sent from a section to a section (2nd box) and also from a group to another group (3rd box). But why do we need messages to be sent to three different types of destinations? To expand, we\u2019ve listed out a few example scenarios for when a particular destination type is used: Send to a node - only concerns that node Send to a section - accepting a new node into the section Send to a group - storing a piece of data By using this logic, we can now understand message relay. Message Relay We\u2019ll run through an example to help us understand message relay. Here we are sending a node (A) in section 00 to a node (X) in section 11. When any node tries to send a message, it must first accumulate information that is required to send the message (hence it\u2019s called the Accumulating Node). In addition to the message, it also has to have a quorum of signatures from the other nodes in its Section to confirm that it is validly allowed to send a message. That quorum is defined as a simple majority of nodes in a Section (so in this example, there are 6 nodes. If B C signs it, it reaches quorum. By getting a Quorum of signatures, it proves that it is a trusted sender in the eyes of the Network. If the node did not have a quorum of signatures from its Section, it would simply be an untrusted message as you can\u2019t trust a single node (which could be malicious). A now has a quorum of its signatures. A being in Section 00 identifies its neighbour as 10. In that Section, node is passed the message to G as it's closest to the hash to the message. G now has it. This is classed as a \u2018hop\u2019. Once it is as G in Section 10, she now identifies her neighbour as 11 where is where the destination X lives. This is passed over and now with message relay is complete. As you see Section 01 is greyed out. This is because the message doesn't need to traverse to that section to get to its destination. Messages that traverse the Alpha 2 Network currently don\u2019t require a quorum of signatures. This means that any malicious node could generate fictitious keypair identities for nodes that it claims are valid nodes in Sections further back in the message chain - and the recipient would have no way of checking this. In the above example as 11 does not know 00 they are not aware of the member list of 00. Therefore, G could create false key pairs which look like nodes from section 00 (ie with the prefix 00). G could send a message to X claiming it was from A and X has no way to validate this. Secure message relay mitigates this as a quorum of 01 will have signed the member list of 00 and these signatures will be attached to the message. As X knows and trust the members of 01 their signatures on the membership of 00 provides validity to the message coming from a true A. We\u2019ll now go into this in more detail. Secure Message Relay (SMR) So Secure Message Relay in Fleming gives the SAFE Network a way of ensuring that any messages sent across isolated parts of the Network (via hops through Neighbours) can be verified as trustworthy - enabling the Network to scale infinitely without weakening the trust requirements. This is not a problem that any other project today has been able to solve (as far as we are aware). In simple terms: SMR simply a chain of trust / validating the senders (not the message) Before we go any further we\u2019ll discuss Accumulation and Routes briefly. Accumulation Each message requires a quorum of signatures in order that it can be trusted by the recipient. There are two options here on quorum: Accumulating at source = collating at source Accumulating at destination = collating at destination In the Network we use the first option as it takes less messages and is more efficient. Here is an example: As you can see, the accumulation at source is a simpler route with less messages and is more efficient. The accumulation at destination, the network is firing messages through any means possible in hope one lands and is acknowledged by the destination node. Routes Pierre Chevalier: Also to keep in mind that for Fleming we're not using disjoint routes but rather \"n-to-n\" communications (probably between 1/3 of elders in each section) How do the nodes know they have the correct message? Let\u2019s use another example. The message sender is Section 00 and A is the accumulating node. The next step is G which is determined by which node is closest (XOR) to the hash of the message. Closeness to a hash is used to balance load across the network. To avoid a single point of failure, the source will send a message to a destination and they will wait for an ACK. ACK (acknowledgement) is quorum at the destination that the message has got through. If the source does not receive an ACK within a given time frame, the source will keep trying until one is received. Routing of messages on SAFE is subject to time limits to ensure the Network is working as intended and to ensure that false messages are not transferred. You can't lie about receiving an ACK. If they don't get an ACK, the section will choose another node and different route. In the example below, the blue line represents the first route however no ACK was received. As the ranking is defined by XOR, the 2nd attempt on route 2 is then defined on the 2nd closest XOR in each section. This process continues until an ACK is received. Nadia Burborough: subject to time limits one of the fundamentals is 'we will not use time' in the network - just something to be cautious of when stating 'timelimits'. I know there are various time limits used - I just don't know if they are here to stay or all just an interim measure? 'You can't lie about receiving an ACK.' -- really? Routes Convergence This is when routes are happening in different hops. This example above is Section 00 sending a message to Section 11. A is the accumulating node and sending it through D. However, D in Section 01 is malicious and doesn't send the message to the given destination 11. However in a network of disjoint sections we have churn. So the nodes are not static in each section. So in the example below, Section 01 has received a new node X. The next Node, B, then tries to send the message again but as now X is first in the list so it hits D again. Secure Message Relay Each time a section performs churn they notify their neighbours of any updates to their section info. Once a neighbour has the new info each member performs validations on this change, passes it through PARSEC and signs the PARSEC event. Quorum needs to be reached, then these signed events are attached the neighbour info. When a single node is sending a messages this signed neighbour info is attached so the destination can validate the sender even though they are not neighbours. This info includes the signatures of known and trusted nodes as well as the key pairs of the sender (in this example) this means no node along the journey can falsify the message or its sender. Our info: what we know in our section Their Knowledge: what your neighbours know about you as far as we know Neighbour info: what we know about our neighbours Successors: Successors are added to the meta-info, to show the sequence of section versions from the version indicated in TheirInfo and the current version. This is done in case the neighbours have a differing version of our section than the sending section believes This is best explained through an example, please see below: Worked example --------------------------------------|----------------------------------------- Network set up | This is the given network set up. | Pfx-10 { | Here we can see we have 4 Prf. Sections /* Nodes: A(was added in A4) .. */ | with nodes A, B, C D. | - Our-Infos: | If we take PrfSec 10, we see the nodes is A A1,A2,A3,A4,A5 | and was added when they were at version A4. - Their-Knowledge: | 00-A2, 11-A4 | In our section 10, we know that we\u2019re on A5. - Neighbour-Infos: | 11(B3)-A3, 10(C4)-A2 | Our neighbours 00 know we\u2019re on A2 11 A4. } | You can see they don't have the most up to | date information and this is due to churn. Pfx-11 { | /* Nodes: B(was added in B2) .. */ | We know we signed B3 in Section 11 and C4 in 10. | - Our-Infos: | B1,B2,B3,B4 | - Their-Knowledge: | 10-B2, 01-B3 | - Neighbour-Infos: | 10(A5)-B3, 01(D4)-B3 | } | | Pfx-00 { | /* Nodes: C(was added in C3) .. */ | | - Our-Infos: | C1,C2,C3,C4,C5 | - Their-Knowledge: | 01-C2, 10-C3 | - Neighbour-Infos: | 10(A3)-C1, 01(D4)-C3 | } | | Pfx-01 { | /* Nodes: D(was added in D4) .. */ | | - Our-Infos: | D1,D2,D3,D4,D5 | - Their-Knowledge: | 00-D3, 11-D3 | - Neighbour-Infos: | 00(C3)-D2, 11(B4)-D4 | } | | --------------------------------------|----------------------------------------- Q: Quorum | PS: ProvingSections | M: Message | | M { | Here is the message. So the src (source) is src: MN(A) | a MN (managednode) A. We know A is in PfxSec 10. dst: PfxSec(01) | Dst (destination) is were the node is going. content: \u201cBye\u201d | In this instance it's going to PrxSec 01. } | | This example means we\u2019re going from a | ManagedNode to a Prefix Section. meta-info { | src_section: None | The meta info is empty at the moment. sigs_of_msg: None | PS: Empty | } | | --------------------------------------|----------------------------------------- Start at A (prf. 10) | The source is a ManagedNode A therefore it does not | need to receive Q before it goes on its journey. Node A can sign the message | --------------------------------------|----------------------------------------- | Neighbours are sections with 1 change in the | prefix. For example, in this instance, A needs to get to 01, therefore uses | 00 is a neighbour of 10, as is 00 is a 00 (its neighbour) as a hop. | neighbour of 01. (destination). 01 and 10 | are not neighbours as 2 changes are needed | in the digits. | This example, section 11 is ignored as its | not required to traverse. --------------------------------------|----------------------------------------- | Pfx-10 | { In 00, A identifies C as its closest | /* Nodes: A(was added in A4) .. */ in hash. | | - Our-Infos: A1,A2,A3,A4,A5 PS::sigs (A4, Q of A4 sign A5), | - Their-Knowledge: 00-A2, 11-A4 forward proofs | - Neighbour-Infos: 11(B3)-A3, 10(C4)-A2 PS::sigs (A3, Q of A3 sign A4), | } PS::sigs (A2, Q of A2 sign A3), | PS::successor(A3), reverse proof | A knows from Their_Know that 00 knows up to A2. PS::successor(A4), | A therefore attaches signatures up to A2 PS::successor(A5) | successors up it its latest version, A5 | so it can make sure the most up to date V is sent over. A then sends \u201cM + meta info\u201d to C | --------------------------------------|----------------------------------------- HOP --------------------------------------|----------------------------------------- The message now is with C | Pfx-00 | { C trims from the bottom to the top | /* Nodes: C(was added in C3) .. */ until it gets to where it trusts (A3) | | - Our-Infos: C1,C2,C3,C4,C5 PS::sigs (A4, Q of A4 sign A5), | - Their-Knowledge: 01-C2, 10-C3 PS::sigs (A3, Q of A3 sign A4) | - Neighbour-Infos: 10(A3)-C1, 01(D4)-C3 PS:: successors (A3) | | In the Neigh_Info, we see that C knows C can then relay this as it trusts | about up to A3 in section 10 (the previous up to A3 | section from where the message came from). | | By removing the excess (trimming) the message | ready to send. Trimming removes the unnecessary | information, he only needs up to what he trusts. | Ask, do i trust (Y/n) keep going to I trust | don't need to go any further. --------------------------------------|----------------------------------------- | Pfx-00 C calculates the next hop as D in 01 | { (the destination). | /* Nodes: C(was added in C3) .. */ | PS::sigs (A4, Q of A4 sign A5), | - Our-Infos: C1,C2,C3,C4,C5 PS::sigs (A3, Q of A3 sign A4), | - Their-Knowledge: 01-C2, 10-C3 PS:: successors (A3) | - Neighbour-Infos: 10(A3)-C1, 01(D4)-C3 PS::sigs (C1, Q of C1 sign A3) | PS:: successor (C2) | We know that A3 has been signed by C1 from PS:: successor (C3) | the Neigh_info in the network set up PS:: successor (C4) | PS:: successor (C5) | In this section we know up to C5 so we must | add in Successors up to that version however We can now relay to D in 01 | they know up to C2 so that must be included, | so up to their knowledge and current versions. --------------------------------------|----------------------------------------- HOP --------------------------------------|----------------------------------------- The message is now in D | | Pfx-01 { D trims to the point it trusts | /* Nodes: D(was added in D4) .. */ | PS::sigs (A4, Q of A4 sign A5), | - Our-Infos: D1,D2,D3,D4,D5 PS::sigs (A3, Q of A3 sign A4), | - Their-Knowledge: 00-D3, 11-D3 PS:: successors (A3) | - Neighbour-Infos: 00(C3)-D2, 11(B4)-D4 PS::sigs (C1, Q of C1 sign A3) | PS:: successor (C2) | D knows up to C3 from the previous section PS:: successor (C3) | | D now has the following info: | | M { | src: MN(A) | dst: PfxSec(01) | content: \u201cBye\u201d | } | | meta-info A5 | src_section: sigs from Q of A5 for M | (add in prf to add the sec info) | sigs_of_msg: | | PS::sigs (A4, Q of A4 sign A5), | PS::sigs (A3, Q of A3 sign A4), | PS:: successors (A3) | PS::sigs (C1, Q of C1 sign A3) | PS:: successor (C2) | PS:: successor (C3) | } | | Validation: | | C3 is known | By going through the validation process, C3 is the successor of C2 | starting from the bottom, it checks it C2 is the successor of C1 | has all the relevant info to be able to A3 is signed by Q of C1 | trust the message. D can trust the message M C1 signs A3 | is genuine and from a genuine source section 10 A3 signs A4 | A4 signs A5 | | | A5 is the src_section which signd the | message M. | --------------------------------------|----------------------------------------- D swarms the message to all in Pfx.01 | Swarm this section as the destination is | labeled as 01, so all nodes need the message --------------------------------------|----------------------------------------- Features Validation at the point of destination to ensure the meta info is correct and therefore is trustworthy Digital signatures Quorum Routes Benefits It is a secure way to make sure only non-malicious communications are being sent across a dynamic network","title":"Message Relay & SMR"},{"location":"05_messaging/#message-relay-smr","text":"","title":"Message Relay &amp; SMR"},{"location":"05_messaging/#summary","text":"Sending and / or receiving a new message from a source to a destination","title":"Summary"},{"location":"05_messaging/#status","text":"Message relay - Alpha 2 / SMR - Fleming","title":"Status"},{"location":"05_messaging/#how-it-works","text":"","title":"How it works"},{"location":"05_messaging/#traversal-logic","text":"While nodes only maintain an awareness of their neighbouring nodes, and connect when necessary, if a message needs to travel across the network out with its neighbouring nodes, how do messages reach their destination? The current mechanism is passing a message between two distant sections relies on a chain of relay nodes, one per section, across the network. All of the relaying nodes then pass the message to all of the relaying nodes in the next hop (jumping across sections) making it certain that the message will make it to the recipient, For a node to message another node, the source node needs to know the destination nodes address, which also indicates the prefix section it\u2019s in. If the source can\u2019t send directly to the destination, it identifies the closest prefix possible from it's knowledge of neighbouring sections. So in the first example below (the first box) the source node (MN) is in prefix 1111 and wants to send to the destination node in prefix 0000. Because it can\u2019t send it directly, source node identifies that it\u2019s neighbour (111) is the next closest to the destination. The message is sent from 1111 111 (first hop). Then the process starts again. Section 111, if can\u2019t send directly to the destination, it identifies the closest prefix possible from it's knowledge of neighbouring sections (it\u2019s neighbouring sections are 011, 101, 110). 111 therefore sends to 011 (second hop). The process repeats. Section 011 looks at its neighbours (001, 010, 111) and identifies 001 as the next closet (third hop). Finally 001 is able to send the message to 000 (final hop to destination) and on to the destination node itself. Using the same logic, you can see how a message is sent from a section to a section (2nd box) and also from a group to another group (3rd box). But why do we need messages to be sent to three different types of destinations? To expand, we\u2019ve listed out a few example scenarios for when a particular destination type is used: Send to a node - only concerns that node Send to a section - accepting a new node into the section Send to a group - storing a piece of data By using this logic, we can now understand message relay.","title":"Traversal Logic"},{"location":"05_messaging/#message-relay","text":"We\u2019ll run through an example to help us understand message relay. Here we are sending a node (A) in section 00 to a node (X) in section 11. When any node tries to send a message, it must first accumulate information that is required to send the message (hence it\u2019s called the Accumulating Node). In addition to the message, it also has to have a quorum of signatures from the other nodes in its Section to confirm that it is validly allowed to send a message. That quorum is defined as a simple majority of nodes in a Section (so in this example, there are 6 nodes. If B C signs it, it reaches quorum. By getting a Quorum of signatures, it proves that it is a trusted sender in the eyes of the Network. If the node did not have a quorum of signatures from its Section, it would simply be an untrusted message as you can\u2019t trust a single node (which could be malicious). A now has a quorum of its signatures. A being in Section 00 identifies its neighbour as 10. In that Section, node is passed the message to G as it's closest to the hash to the message. G now has it. This is classed as a \u2018hop\u2019. Once it is as G in Section 10, she now identifies her neighbour as 11 where is where the destination X lives. This is passed over and now with message relay is complete. As you see Section 01 is greyed out. This is because the message doesn't need to traverse to that section to get to its destination. Messages that traverse the Alpha 2 Network currently don\u2019t require a quorum of signatures. This means that any malicious node could generate fictitious keypair identities for nodes that it claims are valid nodes in Sections further back in the message chain - and the recipient would have no way of checking this. In the above example as 11 does not know 00 they are not aware of the member list of 00. Therefore, G could create false key pairs which look like nodes from section 00 (ie with the prefix 00). G could send a message to X claiming it was from A and X has no way to validate this. Secure message relay mitigates this as a quorum of 01 will have signed the member list of 00 and these signatures will be attached to the message. As X knows and trust the members of 01 their signatures on the membership of 00 provides validity to the message coming from a true A. We\u2019ll now go into this in more detail.","title":"Message Relay"},{"location":"05_messaging/#secure-message-relay-smr","text":"So Secure Message Relay in Fleming gives the SAFE Network a way of ensuring that any messages sent across isolated parts of the Network (via hops through Neighbours) can be verified as trustworthy - enabling the Network to scale infinitely without weakening the trust requirements. This is not a problem that any other project today has been able to solve (as far as we are aware). In simple terms: SMR simply a chain of trust / validating the senders (not the message) Before we go any further we\u2019ll discuss Accumulation and Routes briefly.","title":"Secure Message Relay (SMR)"},{"location":"05_messaging/#accumulation","text":"Each message requires a quorum of signatures in order that it can be trusted by the recipient. There are two options here on quorum: Accumulating at source = collating at source Accumulating at destination = collating at destination In the Network we use the first option as it takes less messages and is more efficient. Here is an example: As you can see, the accumulation at source is a simpler route with less messages and is more efficient. The accumulation at destination, the network is firing messages through any means possible in hope one lands and is acknowledged by the destination node.","title":"Accumulation"},{"location":"05_messaging/#routes","text":"Pierre Chevalier: Also to keep in mind that for Fleming we're not using disjoint routes but rather \"n-to-n\" communications (probably between 1/3 of elders in each section) How do the nodes know they have the correct message? Let\u2019s use another example. The message sender is Section 00 and A is the accumulating node. The next step is G which is determined by which node is closest (XOR) to the hash of the message. Closeness to a hash is used to balance load across the network. To avoid a single point of failure, the source will send a message to a destination and they will wait for an ACK. ACK (acknowledgement) is quorum at the destination that the message has got through. If the source does not receive an ACK within a given time frame, the source will keep trying until one is received. Routing of messages on SAFE is subject to time limits to ensure the Network is working as intended and to ensure that false messages are not transferred. You can't lie about receiving an ACK. If they don't get an ACK, the section will choose another node and different route. In the example below, the blue line represents the first route however no ACK was received. As the ranking is defined by XOR, the 2nd attempt on route 2 is then defined on the 2nd closest XOR in each section. This process continues until an ACK is received. Nadia Burborough: subject to time limits one of the fundamentals is 'we will not use time' in the network - just something to be cautious of when stating 'timelimits'. I know there are various time limits used - I just don't know if they are here to stay or all just an interim measure? 'You can't lie about receiving an ACK.' -- really?","title":"Routes"},{"location":"05_messaging/#routes-convergence","text":"This is when routes are happening in different hops. This example above is Section 00 sending a message to Section 11. A is the accumulating node and sending it through D. However, D in Section 01 is malicious and doesn't send the message to the given destination 11. However in a network of disjoint sections we have churn. So the nodes are not static in each section. So in the example below, Section 01 has received a new node X. The next Node, B, then tries to send the message again but as now X is first in the list so it hits D again.","title":"Routes Convergence"},{"location":"05_messaging/#secure-message-relay","text":"Each time a section performs churn they notify their neighbours of any updates to their section info. Once a neighbour has the new info each member performs validations on this change, passes it through PARSEC and signs the PARSEC event. Quorum needs to be reached, then these signed events are attached the neighbour info. When a single node is sending a messages this signed neighbour info is attached so the destination can validate the sender even though they are not neighbours. This info includes the signatures of known and trusted nodes as well as the key pairs of the sender (in this example) this means no node along the journey can falsify the message or its sender. Our info: what we know in our section Their Knowledge: what your neighbours know about you as far as we know Neighbour info: what we know about our neighbours Successors: Successors are added to the meta-info, to show the sequence of section versions from the version indicated in TheirInfo and the current version. This is done in case the neighbours have a differing version of our section than the sending section believes This is best explained through an example, please see below:","title":"Secure Message Relay"},{"location":"05_messaging/#worked-example","text":"--------------------------------------|----------------------------------------- Network set up | This is the given network set up. | Pfx-10 { | Here we can see we have 4 Prf. Sections /* Nodes: A(was added in A4) .. */ | with nodes A, B, C D. | - Our-Infos: | If we take PrfSec 10, we see the nodes is A A1,A2,A3,A4,A5 | and was added when they were at version A4. - Their-Knowledge: | 00-A2, 11-A4 | In our section 10, we know that we\u2019re on A5. - Neighbour-Infos: | 11(B3)-A3, 10(C4)-A2 | Our neighbours 00 know we\u2019re on A2 11 A4. } | You can see they don't have the most up to | date information and this is due to churn. Pfx-11 { | /* Nodes: B(was added in B2) .. */ | We know we signed B3 in Section 11 and C4 in 10. | - Our-Infos: | B1,B2,B3,B4 | - Their-Knowledge: | 10-B2, 01-B3 | - Neighbour-Infos: | 10(A5)-B3, 01(D4)-B3 | } | | Pfx-00 { | /* Nodes: C(was added in C3) .. */ | | - Our-Infos: | C1,C2,C3,C4,C5 | - Their-Knowledge: | 01-C2, 10-C3 | - Neighbour-Infos: | 10(A3)-C1, 01(D4)-C3 | } | | Pfx-01 { | /* Nodes: D(was added in D4) .. */ | | - Our-Infos: | D1,D2,D3,D4,D5 | - Their-Knowledge: | 00-D3, 11-D3 | - Neighbour-Infos: | 00(C3)-D2, 11(B4)-D4 | } | | --------------------------------------|----------------------------------------- Q: Quorum | PS: ProvingSections | M: Message | | M { | Here is the message. So the src (source) is src: MN(A) | a MN (managednode) A. We know A is in PfxSec 10. dst: PfxSec(01) | Dst (destination) is were the node is going. content: \u201cBye\u201d | In this instance it's going to PrxSec 01. } | | This example means we\u2019re going from a | ManagedNode to a Prefix Section. meta-info { | src_section: None | The meta info is empty at the moment. sigs_of_msg: None | PS: Empty | } | | --------------------------------------|----------------------------------------- Start at A (prf. 10) | The source is a ManagedNode A therefore it does not | need to receive Q before it goes on its journey. Node A can sign the message | --------------------------------------|----------------------------------------- | Neighbours are sections with 1 change in the | prefix. For example, in this instance, A needs to get to 01, therefore uses | 00 is a neighbour of 10, as is 00 is a 00 (its neighbour) as a hop. | neighbour of 01. (destination). 01 and 10 | are not neighbours as 2 changes are needed | in the digits. | This example, section 11 is ignored as its | not required to traverse. --------------------------------------|----------------------------------------- | Pfx-10 | { In 00, A identifies C as its closest | /* Nodes: A(was added in A4) .. */ in hash. | | - Our-Infos: A1,A2,A3,A4,A5 PS::sigs (A4, Q of A4 sign A5), | - Their-Knowledge: 00-A2, 11-A4 forward proofs | - Neighbour-Infos: 11(B3)-A3, 10(C4)-A2 PS::sigs (A3, Q of A3 sign A4), | } PS::sigs (A2, Q of A2 sign A3), | PS::successor(A3), reverse proof | A knows from Their_Know that 00 knows up to A2. PS::successor(A4), | A therefore attaches signatures up to A2 PS::successor(A5) | successors up it its latest version, A5 | so it can make sure the most up to date V is sent over. A then sends \u201cM + meta info\u201d to C | --------------------------------------|----------------------------------------- HOP --------------------------------------|----------------------------------------- The message now is with C | Pfx-00 | { C trims from the bottom to the top | /* Nodes: C(was added in C3) .. */ until it gets to where it trusts (A3) | | - Our-Infos: C1,C2,C3,C4,C5 PS::sigs (A4, Q of A4 sign A5), | - Their-Knowledge: 01-C2, 10-C3 PS::sigs (A3, Q of A3 sign A4) | - Neighbour-Infos: 10(A3)-C1, 01(D4)-C3 PS:: successors (A3) | | In the Neigh_Info, we see that C knows C can then relay this as it trusts | about up to A3 in section 10 (the previous up to A3 | section from where the message came from). | | By removing the excess (trimming) the message | ready to send. Trimming removes the unnecessary | information, he only needs up to what he trusts. | Ask, do i trust (Y/n) keep going to I trust | don't need to go any further. --------------------------------------|----------------------------------------- | Pfx-00 C calculates the next hop as D in 01 | { (the destination). | /* Nodes: C(was added in C3) .. */ | PS::sigs (A4, Q of A4 sign A5), | - Our-Infos: C1,C2,C3,C4,C5 PS::sigs (A3, Q of A3 sign A4), | - Their-Knowledge: 01-C2, 10-C3 PS:: successors (A3) | - Neighbour-Infos: 10(A3)-C1, 01(D4)-C3 PS::sigs (C1, Q of C1 sign A3) | PS:: successor (C2) | We know that A3 has been signed by C1 from PS:: successor (C3) | the Neigh_info in the network set up PS:: successor (C4) | PS:: successor (C5) | In this section we know up to C5 so we must | add in Successors up to that version however We can now relay to D in 01 | they know up to C2 so that must be included, | so up to their knowledge and current versions. --------------------------------------|----------------------------------------- HOP --------------------------------------|----------------------------------------- The message is now in D | | Pfx-01 { D trims to the point it trusts | /* Nodes: D(was added in D4) .. */ | PS::sigs (A4, Q of A4 sign A5), | - Our-Infos: D1,D2,D3,D4,D5 PS::sigs (A3, Q of A3 sign A4), | - Their-Knowledge: 00-D3, 11-D3 PS:: successors (A3) | - Neighbour-Infos: 00(C3)-D2, 11(B4)-D4 PS::sigs (C1, Q of C1 sign A3) | PS:: successor (C2) | D knows up to C3 from the previous section PS:: successor (C3) | | D now has the following info: | | M { | src: MN(A) | dst: PfxSec(01) | content: \u201cBye\u201d | } | | meta-info A5 | src_section: sigs from Q of A5 for M | (add in prf to add the sec info) | sigs_of_msg: | | PS::sigs (A4, Q of A4 sign A5), | PS::sigs (A3, Q of A3 sign A4), | PS:: successors (A3) | PS::sigs (C1, Q of C1 sign A3) | PS:: successor (C2) | PS:: successor (C3) | } | | Validation: | | C3 is known | By going through the validation process, C3 is the successor of C2 | starting from the bottom, it checks it C2 is the successor of C1 | has all the relevant info to be able to A3 is signed by Q of C1 | trust the message. D can trust the message M C1 signs A3 | is genuine and from a genuine source section 10 A3 signs A4 | A4 signs A5 | | | A5 is the src_section which signd the | message M. | --------------------------------------|----------------------------------------- D swarms the message to all in Pfx.01 | Swarm this section as the destination is | labeled as 01, so all nodes need the message --------------------------------------|-----------------------------------------","title":"Worked example"},{"location":"05_messaging/#features","text":"Validation at the point of destination to ensure the meta info is correct and therefore is trustworthy Digital signatures Quorum Routes","title":"Features"},{"location":"05_messaging/#benefits","text":"It is a secure way to make sure only non-malicious communications are being sent across a dynamic network","title":"Benefits"},{"location":"06_chain/","text":"Chain Summary The chain is a record of action, decisions and activity of sections and their neighbours. It stores Section Info, Proofs, and Neighbour Info for the purposes of relaying it to other sections. The chain is not linear but instead should be visualised as a chain of trust . Status New How it works The chain is a record of action, decisions and activity of sections in order to give clarity to others who do not see the gossip graph, membership list or events. In the case of PARSEC interesting blocks and consensus blocks are recorded on the chain. The chain exists to relay section info which has been verified (by a quorum of signatures) to other sections. The chain is not linear but instead should be visualised as a chain of trust . Each section has a linear sequence but they also see their neighbour's linear sequence thus creating the web. Chains are written to the memory of the node and reside there for the lifetime of the session. Things that are kept on the chain Proofs (signatures of quorum members of the section) Neighbour info Section info is an object that contains info of the section that is signed by a quorum of members, section info includes: Section Prefix - the first numbers at the beginning on the XOR address that define the nodes section Version - a number which increases incrementally as members change Members - public identity (public key and encryption key) Previous hash - previous section info Hash (all of the above) Previous hash is a list, comparable to a blockchain that points to previous section info, for example. there will be 2 hashes of 2 previous section info when a merge has been completed. Membership: Always changes by one except in the case of merges when all nodes from the merging section are added at once. Versions: The members of a section at a given point in time. Members can only change (add/leave) one at a time, and the version increases by one with each change. Changes are singular. Except in the case of merges where there may be a version shift in one child. The child with the smaller version will experience a version shift (by more than one), while the version number of the other child increase incrementally by one. Each version will be signed by a quorum of members to be considered valid by another section. A version shift change can be seen as a bug. Unless accompanied by the following as these would highlight a merge. - A prefix change - A membership list change shift In the case of a split, children will hold the previous section info from the parent in the previous hash. The chain captures OurInfo as well as NeighbourInfo . The advantage of recording this sequence is that a peer cannot lie and/or alter the sequence or entries as the hashes are sequential and incremental. OurInfo: maintained by self and holds every piece of historic section info NeighbourInfo: maintain info about neighbours, however, only the latest state is maintained. This is replaced after each churn event. In order to update neighbour info the section must receive signatures from a quorum of known members. The chain would also hold signatures to verify each section info from a quorum of section members. Worked example The following example incorporates these concepts: **Network Genesis - Min section size 3, Buffer 0** Si: {Members: (0,1), Prefix: ( ), Version (0), PreviousHash ( )} Si: {Members: (0,1,2), Prefix: ( ), Version (1), PreviousHash (Si 0)}, proofs Si 0 Si: {Members: (0,1,2,3), Prefix: ( ), Version (2), PreviousHash (Si 1)}, proofs Si 1 Si: {Members: (0,1,2,3,4), Prefix: ( ), Version (3), PreviousHash (Si 2)}, Proofs Si 2 New node(5) joins triggering a split Section splits Si: {Members: (0,1,2,3) Si:{Members: (4,5,6) Prefix: (0) Prefix: (1) Version (4) Version (4) PreviousHash (Si 3)} PreviousHash (Si 3)} Proofs Si 3 Proofs Si 3 No change +1 (node 8 joins) Si: {Members: (0,1,2,3) Si: {Members:(4,5,6,8) Prefix: (0) Prefix: (1) Version (4) Version (5) PreviousHash (Si 3)} PreviousHash (Si 4)} Proofs Si 3 Proofs Si 4 - 1 (node 2 leaves) - 1 (node 6 leaves) Si: {Members: (0,1,3) Si:{Members: (4,5,8) Prefix: (0) Prefix: (1) Version (5) Version (6) PreviousHash (Si 4)} PreviousHash (Si 5)} Proofs Si 4 Proofs Si 5 No change - 1 (node 5 leaves) Si: {Members: (0,1,3) Si: {Members: (4,8) Prefix: (0) Prefix: (1) Version (5) Version (7) PreviousHash (Si 4)} PreviousHash (Si 6)} Proofs Si 4 Proofs Si 6 Section (Prefix 1) falls below min section size - merge triggered Si: {Members: (0,1,3,4,8) Prefix:( ) Version (8) PreviousHash (Si 5, Si 7) Proofs Si 5, Si 7 Features Linear and non-linear chain (chain of trust) Hash entries are only sequential and incremental Benefits Enables a record of action, decisions and activity of sections to be passed between neighbouring sections.","title":"Chain"},{"location":"06_chain/#chain","text":"","title":"Chain"},{"location":"06_chain/#summary","text":"The chain is a record of action, decisions and activity of sections and their neighbours. It stores Section Info, Proofs, and Neighbour Info for the purposes of relaying it to other sections. The chain is not linear but instead should be visualised as a chain of trust .","title":"Summary"},{"location":"06_chain/#status","text":"New","title":"Status"},{"location":"06_chain/#how-it-works","text":"The chain is a record of action, decisions and activity of sections in order to give clarity to others who do not see the gossip graph, membership list or events. In the case of PARSEC interesting blocks and consensus blocks are recorded on the chain. The chain exists to relay section info which has been verified (by a quorum of signatures) to other sections. The chain is not linear but instead should be visualised as a chain of trust . Each section has a linear sequence but they also see their neighbour's linear sequence thus creating the web. Chains are written to the memory of the node and reside there for the lifetime of the session. Things that are kept on the chain Proofs (signatures of quorum members of the section) Neighbour info Section info is an object that contains info of the section that is signed by a quorum of members, section info includes: Section Prefix - the first numbers at the beginning on the XOR address that define the nodes section Version - a number which increases incrementally as members change Members - public identity (public key and encryption key) Previous hash - previous section info Hash (all of the above) Previous hash is a list, comparable to a blockchain that points to previous section info, for example. there will be 2 hashes of 2 previous section info when a merge has been completed. Membership: Always changes by one except in the case of merges when all nodes from the merging section are added at once. Versions: The members of a section at a given point in time. Members can only change (add/leave) one at a time, and the version increases by one with each change. Changes are singular. Except in the case of merges where there may be a version shift in one child. The child with the smaller version will experience a version shift (by more than one), while the version number of the other child increase incrementally by one. Each version will be signed by a quorum of members to be considered valid by another section. A version shift change can be seen as a bug. Unless accompanied by the following as these would highlight a merge. - A prefix change - A membership list change shift In the case of a split, children will hold the previous section info from the parent in the previous hash. The chain captures OurInfo as well as NeighbourInfo . The advantage of recording this sequence is that a peer cannot lie and/or alter the sequence or entries as the hashes are sequential and incremental. OurInfo: maintained by self and holds every piece of historic section info NeighbourInfo: maintain info about neighbours, however, only the latest state is maintained. This is replaced after each churn event. In order to update neighbour info the section must receive signatures from a quorum of known members. The chain would also hold signatures to verify each section info from a quorum of section members.","title":"How it works"},{"location":"06_chain/#worked-example","text":"The following example incorporates these concepts: **Network Genesis - Min section size 3, Buffer 0** Si: {Members: (0,1), Prefix: ( ), Version (0), PreviousHash ( )} Si: {Members: (0,1,2), Prefix: ( ), Version (1), PreviousHash (Si 0)}, proofs Si 0 Si: {Members: (0,1,2,3), Prefix: ( ), Version (2), PreviousHash (Si 1)}, proofs Si 1 Si: {Members: (0,1,2,3,4), Prefix: ( ), Version (3), PreviousHash (Si 2)}, Proofs Si 2 New node(5) joins triggering a split Section splits Si: {Members: (0,1,2,3) Si:{Members: (4,5,6) Prefix: (0) Prefix: (1) Version (4) Version (4) PreviousHash (Si 3)} PreviousHash (Si 3)} Proofs Si 3 Proofs Si 3 No change +1 (node 8 joins) Si: {Members: (0,1,2,3) Si: {Members:(4,5,6,8) Prefix: (0) Prefix: (1) Version (4) Version (5) PreviousHash (Si 3)} PreviousHash (Si 4)} Proofs Si 3 Proofs Si 4 - 1 (node 2 leaves) - 1 (node 6 leaves) Si: {Members: (0,1,3) Si:{Members: (4,5,8) Prefix: (0) Prefix: (1) Version (5) Version (6) PreviousHash (Si 4)} PreviousHash (Si 5)} Proofs Si 4 Proofs Si 5 No change - 1 (node 5 leaves) Si: {Members: (0,1,3) Si: {Members: (4,8) Prefix: (0) Prefix: (1) Version (5) Version (7) PreviousHash (Si 4)} PreviousHash (Si 6)} Proofs Si 4 Proofs Si 6 Section (Prefix 1) falls below min section size - merge triggered Si: {Members: (0,1,3,4,8) Prefix:( ) Version (8) PreviousHash (Si 5, Si 7) Proofs Si 5, Si 7","title":"Worked example"},{"location":"06_chain/#features","text":"Linear and non-linear chain (chain of trust) Hash entries are only sequential and incremental","title":"Features"},{"location":"06_chain/#benefits","text":"Enables a record of action, decisions and activity of sections to be passed between neighbouring sections.","title":"Benefits"},{"location":"07_parsec/","text":"PARSEC Reputation system with incentivise good behaviour to protect the Network from malicious nodes. Temp - Glossary of Terms (from RFC) Status In Fleming, PARSEC v2 whitepaper released Background information Why do we need consensus in an asynchronous network? The SAFE Network is Asynchronous. Asynchronous is the opposite of synchronous, which means happening at the same time. Think of \u201csynchronous\u201d as \u201cin synch\u201d and asynchronous as \u201cout of synch.\u201d In Synchronous consensus, all communication proceeds in rounds. This can be because synchronous consensus is easier to model than real life, which is inherently asynchronous in order etc. For example, a phone call is pretty synchronous because person 1 calls, waits for someone to pick up, then speaks, then waist for person 2 to answer, then speaks again. If the person 2 is silent for a minute or so after person 1 stopped speaking, they will assume there is a problem and hang up (abort the protocol). An example of asynchrony would be Slack where many conversations are happening and a delay in a marketing conversation will have no influence on a conversation within a given channel. An asynchronous protocol is one in which no matter how bad the delays in communications between parties, as long as every message is eventually delivered, the protocol eventually terminates (or in other words, doesn\u2019t stall indefinitely) So what does that have to do with consensus? Such mechanisms are essential in dencrealisted networks, as there is no central authority to provide truth. Essentially, a consensus method is employed to allow all actors in the network to come to agreement on what the true information is. This is done by the majority of the network agreeing (Quorum) on the information presented. Additionally, consensus allows structure of the Network to be maintained, by allowing each node to know exactly how to cooperate with other nodes at any time because we know that we will all agree on the meaning of our exchanges. What's in our consensus algorithm: Asynchronous - because our Network is run by computers, latency is unpredictable. This means that without asynchrony, a malicious node could control the Network for the time it takes a message to be transmitted. Able to work in a Permissionless Setting - because 1) Anyone can run a Vault and try to mess with our protocol, and 2) Nodes can go offline and rejoin when they want, so we need dynamic membership to handle that. Proven with probability one instead of relying on high statistical probability of consensus. Has the Fault Tolerance Level where less than one third of the voting members in a section are faulty or dishonest. Scalable - Our Network wants to store all the data in the world on all the computers in the world, so it has to be theoretically scalable. Open Source - because we want entire access for everyone - where everyone can review the code, contribute if they want to, and know that we are not doing anything malicious. Simple - This will increase security, because it means that anyone in the space can review it. If it is complicated it could take 10 years until someone notices a flaw. Byzantine Fault Tolerance Overview A Byzantine fault is a fault presenting different symptoms to different observers. A network is Byzantine Fault Tolerant (BFT) when it can provide service and reach a consensus in spite of system faults or failures. Consensus algorithms are what makes it possible for distributed networks to solve the Byzantine Generals Problem, even when there are unreliable or malicious actors operating. Background The Byzantine Generals Problem is a thought experiment by Leslie Lamport in which a group of army generals formulate a plan for attacking a city. It was devised to make the problem and impact of malicious nodes operating within a network easier to understand. In its simplest form, the generals must decide whether to attack or retreat. Some generals may prefer to attack, while others prefer to retreat. The important thing is that every general agrees on a common decision, for a halfhearted attack by a few generals would become a rout, and would be worse than either a coordinated attack or a coordinated retreat. The problem is complicated by the presence of treacherous generals who may not only cast a vote for a suboptimal strategy, they may do so selectively. For instance, if nine generals are voting, four of whom support attacking while four others are in favor of retreat, the ninth general may send a vote of retreat to those generals in favor of retreat, and a vote of attack to the rest. Those who received a retreat vote from the ninth general will retreat, while the rest will attack (which may not go well for the attackers). The problem is complicated further by the generals being physically separated and having to send their votes via messengers who may fail to deliver votes or may forge false votes. The objective of Byzantine fault tolerance is to be able to defend against failures of system components with or without symptoms such as malicious or faulty nodes that can prevent other components of the system from reaching an agreement among themselves, where such an agreement is needed for the correct operation of the system. BFT consensus is the ability to tolerate \"byzantine failures\" = malicious behaviour. How it works There are a few components we need to explain first Network events: A network event can be a node joining the section, or a node leaving, or pretty much anything that happens in the network and requires consensus What is gossip?: Gossip is a way for a network of computers to exchange information very efficiently with resilience, emulating the way rumours spread in human societies. Each node picks another node at random and shares info with them. What is a DAG? A Directed Acyclic Graph is a directed graph that has a topological ordering, a sequence of the vertices such that every edge is directed from earlier to later in the sequence. What is a gossip graph? A gossip graph is a record of gossip communications between nodes that consists of gossip events. Each gossip graph will ultimately be comprised of the same events after a period of time (eventual consistency). A gossip graph is a DAG. What is a gossip event? A vertex in the PARSEC gossip graph (which is a DAG), which can be viewed as an entry in the record of gossip communications between nodes (the graph is the record). The actual piece of information that nodes want to share using gossip is only a part of the gossip event, which we call \u201ccontent\u201d or \u201cpayload\u201d. What is an event\u2019s ancestor? An example of an event\u2019s ancestor would be an event\u2019s parent - if two events are connected with an arrow, the event at the base of the arrow is called a parent of the event at the tip. Then, by extension, an ancestor is also a parent of a parent, or a parent of a parent of a parent, and so on. What is seeing? A Gossip Event is seen by a later one if there is a directed path going from the latter to the former in the gossip graph. In the below example, there is a directed line from b_0 to d_4 (blue line) therefore b_0 is \u2018seen\u2019 by d_4. What is an interesting event? An interesting event is a gossip event that has some number of ancestors which contain the same payload - for example, a vote on a node joining. This \u201csome number\u201d depends on something we call \u201cconsensus mode\u201d, for now it can be either a supermajority, or just one. What is strongly seen? This is where an event can be seen by events created by a supermajority of nodes, all of which can be seen by another event. In this example, b_0 is seen by ca_1, b_1 and d_1 (created by 3 out of 4 nodes), all of which are seen by a_1. With a_0 and d_4, the only events seen by d_4 that see a_0 are d_4, a_1 and a_0, which are created by 2/4 nodes, which is not a supermajority (even though these are 3 events). What's an Observer? Observers describe peers which strongly see interesting gossip events which have been seen by a supermajority of peers. Observers are relevant as without observers, events would not be strongly seen, and therefore meta votes would not therefore be cast. Any event that takes place will eventually be seen by an observer. So how does this all work? Using the Gossip Protocol, nodes gossip by selecting another node at random to transmit event history to. The receiving node adds any new information it has not yet seen to its own history When a node receives a request, it creates a new event and sends a response back. This creates a verifiable datalog called a gossip graph. Each gossip graph contains what we call a gossip event. Every gossip event gets added to each nodes gossip graph. Nodes \u2018virtually\u2019 vote on observations seen. Each node analyses the gossip graph and if they believe that it has a record of an event which should go next in the chain then it casts a vote as such A node then counts votes for an event and decides which event should be the next one in order Once a set number of nodes (a supermajority) have voted for an event then the block is considered valid and ready to enter the consensus protocol to reach consensus. To get to consensus, a meta vote is cast. A node answers the question \u201cDoes my oldest observer (observer having been defined above) strongly see an interesting gossip event created by the node I am looking at\u201d. The binary value is true or false. Once a true vote is cast, it means that all honest nodes will also eventually be guaranteed to strongly see the gossip event. The meta voting is best explained through an illustration. The bottom quadrants are estimates and the top are bin_values. So the example below (in red), if we look at a_1, there is a true and false vote in the estimates quadrants. This is because a_1 sees c_0 and b_0 which is a third of nodes. The true value has been added because a_1s self-parent is a_0 and has true in the bottom left quadrant. In the same event, false has been added to bin_values as a_1 sees a_1, c_0 and b_0 and they are all false ( a supermajority - 2/3s). Where the common coin comes in is if there is a tie break in the bin_values. In the example below, a_2 has a true and false value in bin_values. This is when the Common Coin comes in. To achieve Binary (true / false) Byzantine Consensus, a common coin is used. It is essentially used as a tiebreaker, to solve a split where all honest nodes are tied between true and false in the event that a malicious actor is intentionally keeping a tie such that no decision can ever be reached. The coin is used to prevent an attacker from working against honest nodes by manipulating the true/false flips. It introduces an unpredictability that a bad actor cannot predict and so avoids the scenario where they keep the protocol tied and unable to make a decision. Features Common Coin Asynchronous Open source Gossip graph Benefits Unique to SAFE Malice prevention","title":"PARSEC"},{"location":"07_parsec/#parsec","text":"Reputation system with incentivise good behaviour to protect the Network from malicious nodes. Temp - Glossary of Terms (from RFC)","title":"PARSEC"},{"location":"07_parsec/#status","text":"In Fleming, PARSEC v2 whitepaper released","title":"Status"},{"location":"07_parsec/#background-information","text":"","title":"Background information"},{"location":"07_parsec/#why-do-we-need-consensus-in-an-asynchronous-network","text":"The SAFE Network is Asynchronous. Asynchronous is the opposite of synchronous, which means happening at the same time. Think of \u201csynchronous\u201d as \u201cin synch\u201d and asynchronous as \u201cout of synch.\u201d In Synchronous consensus, all communication proceeds in rounds. This can be because synchronous consensus is easier to model than real life, which is inherently asynchronous in order etc. For example, a phone call is pretty synchronous because person 1 calls, waits for someone to pick up, then speaks, then waist for person 2 to answer, then speaks again. If the person 2 is silent for a minute or so after person 1 stopped speaking, they will assume there is a problem and hang up (abort the protocol). An example of asynchrony would be Slack where many conversations are happening and a delay in a marketing conversation will have no influence on a conversation within a given channel. An asynchronous protocol is one in which no matter how bad the delays in communications between parties, as long as every message is eventually delivered, the protocol eventually terminates (or in other words, doesn\u2019t stall indefinitely) So what does that have to do with consensus? Such mechanisms are essential in dencrealisted networks, as there is no central authority to provide truth. Essentially, a consensus method is employed to allow all actors in the network to come to agreement on what the true information is. This is done by the majority of the network agreeing (Quorum) on the information presented. Additionally, consensus allows structure of the Network to be maintained, by allowing each node to know exactly how to cooperate with other nodes at any time because we know that we will all agree on the meaning of our exchanges.","title":"Why do we need consensus in an asynchronous network?"},{"location":"07_parsec/#whats-in-our-consensus-algorithm","text":"Asynchronous - because our Network is run by computers, latency is unpredictable. This means that without asynchrony, a malicious node could control the Network for the time it takes a message to be transmitted. Able to work in a Permissionless Setting - because 1) Anyone can run a Vault and try to mess with our protocol, and 2) Nodes can go offline and rejoin when they want, so we need dynamic membership to handle that. Proven with probability one instead of relying on high statistical probability of consensus. Has the Fault Tolerance Level where less than one third of the voting members in a section are faulty or dishonest. Scalable - Our Network wants to store all the data in the world on all the computers in the world, so it has to be theoretically scalable. Open Source - because we want entire access for everyone - where everyone can review the code, contribute if they want to, and know that we are not doing anything malicious. Simple - This will increase security, because it means that anyone in the space can review it. If it is complicated it could take 10 years until someone notices a flaw.","title":"What's in our consensus algorithm:"},{"location":"07_parsec/#byzantine-fault-tolerance","text":"","title":"Byzantine Fault Tolerance"},{"location":"07_parsec/#overview","text":"A Byzantine fault is a fault presenting different symptoms to different observers. A network is Byzantine Fault Tolerant (BFT) when it can provide service and reach a consensus in spite of system faults or failures. Consensus algorithms are what makes it possible for distributed networks to solve the Byzantine Generals Problem, even when there are unreliable or malicious actors operating.","title":"Overview"},{"location":"07_parsec/#background","text":"The Byzantine Generals Problem is a thought experiment by Leslie Lamport in which a group of army generals formulate a plan for attacking a city. It was devised to make the problem and impact of malicious nodes operating within a network easier to understand. In its simplest form, the generals must decide whether to attack or retreat. Some generals may prefer to attack, while others prefer to retreat. The important thing is that every general agrees on a common decision, for a halfhearted attack by a few generals would become a rout, and would be worse than either a coordinated attack or a coordinated retreat. The problem is complicated by the presence of treacherous generals who may not only cast a vote for a suboptimal strategy, they may do so selectively. For instance, if nine generals are voting, four of whom support attacking while four others are in favor of retreat, the ninth general may send a vote of retreat to those generals in favor of retreat, and a vote of attack to the rest. Those who received a retreat vote from the ninth general will retreat, while the rest will attack (which may not go well for the attackers). The problem is complicated further by the generals being physically separated and having to send their votes via messengers who may fail to deliver votes or may forge false votes. The objective of Byzantine fault tolerance is to be able to defend against failures of system components with or without symptoms such as malicious or faulty nodes that can prevent other components of the system from reaching an agreement among themselves, where such an agreement is needed for the correct operation of the system. BFT consensus is the ability to tolerate \"byzantine failures\" = malicious behaviour.","title":"Background"},{"location":"07_parsec/#how-it-works","text":"There are a few components we need to explain first","title":"How it works"},{"location":"07_parsec/#network-events","text":"A network event can be a node joining the section, or a node leaving, or pretty much anything that happens in the network and requires consensus","title":"Network events:"},{"location":"07_parsec/#what-is-gossip","text":"Gossip is a way for a network of computers to exchange information very efficiently with resilience, emulating the way rumours spread in human societies. Each node picks another node at random and shares info with them.","title":"What is gossip?:"},{"location":"07_parsec/#what-is-a-dag","text":"A Directed Acyclic Graph is a directed graph that has a topological ordering, a sequence of the vertices such that every edge is directed from earlier to later in the sequence.","title":"What is a DAG?"},{"location":"07_parsec/#what-is-a-gossip-graph","text":"A gossip graph is a record of gossip communications between nodes that consists of gossip events. Each gossip graph will ultimately be comprised of the same events after a period of time (eventual consistency). A gossip graph is a DAG.","title":"What is a gossip graph?"},{"location":"07_parsec/#what-is-a-gossip-event","text":"A vertex in the PARSEC gossip graph (which is a DAG), which can be viewed as an entry in the record of gossip communications between nodes (the graph is the record). The actual piece of information that nodes want to share using gossip is only a part of the gossip event, which we call \u201ccontent\u201d or \u201cpayload\u201d.","title":"What is a gossip event?"},{"location":"07_parsec/#what-is-an-events-ancestor","text":"An example of an event\u2019s ancestor would be an event\u2019s parent - if two events are connected with an arrow, the event at the base of the arrow is called a parent of the event at the tip. Then, by extension, an ancestor is also a parent of a parent, or a parent of a parent of a parent, and so on.","title":"What is an event\u2019s ancestor?"},{"location":"07_parsec/#what-is-seeing","text":"A Gossip Event is seen by a later one if there is a directed path going from the latter to the former in the gossip graph. In the below example, there is a directed line from b_0 to d_4 (blue line) therefore b_0 is \u2018seen\u2019 by d_4.","title":"What is seeing?"},{"location":"07_parsec/#what-is-an-interesting-event","text":"An interesting event is a gossip event that has some number of ancestors which contain the same payload - for example, a vote on a node joining. This \u201csome number\u201d depends on something we call \u201cconsensus mode\u201d, for now it can be either a supermajority, or just one.","title":"What is an interesting event?"},{"location":"07_parsec/#what-is-strongly-seen","text":"This is where an event can be seen by events created by a supermajority of nodes, all of which can be seen by another event. In this example, b_0 is seen by ca_1, b_1 and d_1 (created by 3 out of 4 nodes), all of which are seen by a_1. With a_0 and d_4, the only events seen by d_4 that see a_0 are d_4, a_1 and a_0, which are created by 2/4 nodes, which is not a supermajority (even though these are 3 events).","title":"What is strongly seen?"},{"location":"07_parsec/#whats-an-observer","text":"Observers describe peers which strongly see interesting gossip events which have been seen by a supermajority of peers. Observers are relevant as without observers, events would not be strongly seen, and therefore meta votes would not therefore be cast. Any event that takes place will eventually be seen by an observer.","title":"What's an Observer?"},{"location":"07_parsec/#so-how-does-this-all-work","text":"Using the Gossip Protocol, nodes gossip by selecting another node at random to transmit event history to. The receiving node adds any new information it has not yet seen to its own history When a node receives a request, it creates a new event and sends a response back. This creates a verifiable datalog called a gossip graph. Each gossip graph contains what we call a gossip event. Every gossip event gets added to each nodes gossip graph. Nodes \u2018virtually\u2019 vote on observations seen. Each node analyses the gossip graph and if they believe that it has a record of an event which should go next in the chain then it casts a vote as such A node then counts votes for an event and decides which event should be the next one in order Once a set number of nodes (a supermajority) have voted for an event then the block is considered valid and ready to enter the consensus protocol to reach consensus. To get to consensus, a meta vote is cast. A node answers the question \u201cDoes my oldest observer (observer having been defined above) strongly see an interesting gossip event created by the node I am looking at\u201d. The binary value is true or false. Once a true vote is cast, it means that all honest nodes will also eventually be guaranteed to strongly see the gossip event. The meta voting is best explained through an illustration. The bottom quadrants are estimates and the top are bin_values. So the example below (in red), if we look at a_1, there is a true and false vote in the estimates quadrants. This is because a_1 sees c_0 and b_0 which is a third of nodes. The true value has been added because a_1s self-parent is a_0 and has true in the bottom left quadrant. In the same event, false has been added to bin_values as a_1 sees a_1, c_0 and b_0 and they are all false ( a supermajority - 2/3s). Where the common coin comes in is if there is a tie break in the bin_values. In the example below, a_2 has a true and false value in bin_values. This is when the Common Coin comes in. To achieve Binary (true / false) Byzantine Consensus, a common coin is used. It is essentially used as a tiebreaker, to solve a split where all honest nodes are tied between true and false in the event that a malicious actor is intentionally keeping a tie such that no decision can ever be reached. The coin is used to prevent an attacker from working against honest nodes by manipulating the true/false flips. It introduces an unpredictability that a bad actor cannot predict and so avoids the scenario where they keep the protocol tied and unable to make a decision.","title":"So how does this all work?"},{"location":"07_parsec/#features","text":"Common Coin Asynchronous Open source Gossip graph","title":"Features"},{"location":"07_parsec/#benefits","text":"Unique to SAFE Malice prevention","title":"Benefits"},{"location":"08_ageing/","text":"Node Ageing Summary An autonomous and decentralised node reputation system that ranks nodes based on their age. Nodes that have been good citizens of the Network (have good bandwidth, storage and are always online) will have a higher age (reputation) than nodes that have not proven to be as useful. The Network incentivises good behaviour via an incentivisation approach that is rooted in Game Theory. A nodes ability to earn is directly related to its age e.g. a well aged node will earn more for equivalent work than a node with a younger age. If you misbehave you lose trust and lose the incentive. Node Ageing helps to mitigate against Sybil attacks (the attacker subverts the reputation system of a peer-to-peer network by creating a large number of pseudonymous identities and uses them to gain a disproportionately large influence) by making it more time consuming/expensive to target specific network sections by diluting the influence of byzantine nodes across the Network. Status This feature is currently in planning phase, and will be implemented as part of the Fleming release. How it works A node\u2019s age increases every time it is relocated. The age at the point of relocation is arbitrarily picked in time. In the network, trust increases exponentially with age. A node with age 2 ^4 is twice as trustworthy as one with the age 2 ^3. Only nodes that are considered Elders take part in Parsec voting as they are the oldest and most trusted nodes in the section. The top X number of nodes within the section gain the status of Elder and as the network will be constantly moving, there is not a specific age or threshold to gain Elder status. - just whichever nodes are the oldest in the Section at that point in time. However, Nodes may lose Elder status during Churn. Adults are any nodes that are not Elders. Infants are nodes that have just joined the Network. The lower a nodes age the more frequently it is relocated .e.g. A node with age 2 ^4 will get relocated before a node with age 2 ^5 as it has been in the section for less (half) time. Older nodes are relocated less frequently than younger nodes as older nodes are less likely to behave badly, and the consequences would be more costly for them. I e \u201cThe more I trust someone (exponentially), I can keep them in the section longer\u201d. The greater the nodes trust level .i.e. age the longer they can stay within a section. This gives a node a greater amount of time to validate data and be ready if asked for the data thus increasing their ability to earn safecoin. Relocations are resource intensive as nodes validate new areas of responsibility within the Section and there is a large amount of traffic. As described, only Elders take part in Parsec voting, and a Section Quorum is reached based on the majority of the Elders age, but the votes must also come from a majority number of Elders. This avoids trusting an individual node, even one with very high age/reputation. As we have learned elsewhere in this document, It is not possible to pick your own Section, as to do so would potentially enable adversaries to influence consensus thereby controlling the Section and possibly the Network. When a node does bootstrap initially to a Section chosen by the Network, it is quickly relocated to another section. A new node can only join a section when there are no infants (new nodes) in that Section. Node reset (going offline) leads to nodes halving their node age therefore you are incentivised to stay online. Additionally, by punishing network resets it reduces the risk of malicious targeting. Targeting can lead to gaining control and stall consensus The Network\u2019s assessment of a node\u2019s usefulness will continue to adapt over time as it matures. In the existing Alpha 2 Network, a node is assessed via a process of Resource Proof, which is essentially a spot check that takes place only when that node is joining the network. Resource Proof assesses bandwidth and CPU. This mechanism is easy to manipulate as after the initial check a node could then behave maliciously. Within Fleming, the first milestone in which Node Ageing will be running, will require the implementation to be different to that described above. There will be no data on Fleming and therefore no no meaningful work against which to profile. Age will be emulated in Fleming based on Work Units, essentially, how many times a node has seen section membership change, with the Network continually spot checking every time a node ages. This will be harder to manipulate as the timing of these spot checks cannot be predetermined. Features Node Relocation Resource proof Incentivisation tactics Benefits Help mitigate against Sybil attacks When linked with a network currency, an incentive for \u2018good behaviour\u2019","title":"Node Ageing"},{"location":"08_ageing/#node-ageing","text":"","title":"Node Ageing"},{"location":"08_ageing/#summary","text":"An autonomous and decentralised node reputation system that ranks nodes based on their age. Nodes that have been good citizens of the Network (have good bandwidth, storage and are always online) will have a higher age (reputation) than nodes that have not proven to be as useful. The Network incentivises good behaviour via an incentivisation approach that is rooted in Game Theory. A nodes ability to earn is directly related to its age e.g. a well aged node will earn more for equivalent work than a node with a younger age. If you misbehave you lose trust and lose the incentive. Node Ageing helps to mitigate against Sybil attacks (the attacker subverts the reputation system of a peer-to-peer network by creating a large number of pseudonymous identities and uses them to gain a disproportionately large influence) by making it more time consuming/expensive to target specific network sections by diluting the influence of byzantine nodes across the Network.","title":"Summary"},{"location":"08_ageing/#status","text":"This feature is currently in planning phase, and will be implemented as part of the Fleming release.","title":"Status"},{"location":"08_ageing/#how-it-works","text":"A node\u2019s age increases every time it is relocated. The age at the point of relocation is arbitrarily picked in time. In the network, trust increases exponentially with age. A node with age 2 ^4 is twice as trustworthy as one with the age 2 ^3. Only nodes that are considered Elders take part in Parsec voting as they are the oldest and most trusted nodes in the section. The top X number of nodes within the section gain the status of Elder and as the network will be constantly moving, there is not a specific age or threshold to gain Elder status. - just whichever nodes are the oldest in the Section at that point in time. However, Nodes may lose Elder status during Churn. Adults are any nodes that are not Elders. Infants are nodes that have just joined the Network. The lower a nodes age the more frequently it is relocated .e.g. A node with age 2 ^4 will get relocated before a node with age 2 ^5 as it has been in the section for less (half) time. Older nodes are relocated less frequently than younger nodes as older nodes are less likely to behave badly, and the consequences would be more costly for them. I e \u201cThe more I trust someone (exponentially), I can keep them in the section longer\u201d. The greater the nodes trust level .i.e. age the longer they can stay within a section. This gives a node a greater amount of time to validate data and be ready if asked for the data thus increasing their ability to earn safecoin. Relocations are resource intensive as nodes validate new areas of responsibility within the Section and there is a large amount of traffic. As described, only Elders take part in Parsec voting, and a Section Quorum is reached based on the majority of the Elders age, but the votes must also come from a majority number of Elders. This avoids trusting an individual node, even one with very high age/reputation. As we have learned elsewhere in this document, It is not possible to pick your own Section, as to do so would potentially enable adversaries to influence consensus thereby controlling the Section and possibly the Network. When a node does bootstrap initially to a Section chosen by the Network, it is quickly relocated to another section. A new node can only join a section when there are no infants (new nodes) in that Section. Node reset (going offline) leads to nodes halving their node age therefore you are incentivised to stay online. Additionally, by punishing network resets it reduces the risk of malicious targeting. Targeting can lead to gaining control and stall consensus The Network\u2019s assessment of a node\u2019s usefulness will continue to adapt over time as it matures. In the existing Alpha 2 Network, a node is assessed via a process of Resource Proof, which is essentially a spot check that takes place only when that node is joining the network. Resource Proof assesses bandwidth and CPU. This mechanism is easy to manipulate as after the initial check a node could then behave maliciously. Within Fleming, the first milestone in which Node Ageing will be running, will require the implementation to be different to that described above. There will be no data on Fleming and therefore no no meaningful work against which to profile. Age will be emulated in Fleming based on Work Units, essentially, how many times a node has seen section membership change, with the Network continually spot checking every time a node ages. This will be harder to manipulate as the timing of these spot checks cannot be predetermined.","title":"How it works"},{"location":"08_ageing/#features","text":"Node Relocation Resource proof Incentivisation tactics","title":"Features"},{"location":"08_ageing/#benefits","text":"Help mitigate against Sybil attacks When linked with a network currency, an incentive for \u2018good behaviour\u2019","title":"Benefits"}]}